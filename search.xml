<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ROS2常用指令</title>
      <link href="/myblogs/2020/10/25/blog5-ros2-chang-yong-zhi-ling/"/>
      <url>/myblogs/2020/10/25/blog5-ros2-chang-yong-zhi-ling/</url>
      
        <content type="html"><![CDATA[<p>本文记录ROS2常用的命令行操作指令。包括话题，服务，参数，动作等命令行命令。本文参考博客链接为：<a href="https://www.guyuehome.com/category/column/ros2-tutorials。" target="_blank" rel="noopener">https://www.guyuehome.com/category/column/ros2-tutorials。</a><br><a id="more"></a></p><h2 id="一、安装调试过程"><a href="#一、安装调试过程" class="headerlink" title="一、安装调试过程"></a>一、安装调试过程</h2><ul><li>将指令写入环境变量：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    echo "source /opt/ros/foxy/setup.bash" >> ~/.bashrc</code></pre><ul><li>查看环境变量是否写入成功：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    printenv | grep -i ROS</code></pre><ul><li>设置ROS组网ID:</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    export ROS_DOMAIN_ID=<your_domain_id>    echo "export ROS_DOMAIN_ID=<your_domain_id>" >> ~/.bashrc</code></pre><ul><li>安装海龟仿真器：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    sudo apt update    sudo apt install ros-foxy-turtlesim</code></pre><ul><li>检查功能包是否安装成功：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 pkg executables turtlesim</code></pre><ul><li>启动海龟仿真器节点：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 run turtlesim turtlesim_node</code></pre><ul><li>查看节点，话题，服务，动作：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 node list    ros2 topic list    ros2 service list    ros2 action list</code></pre><ul><li>安装rqt工具：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    sudo apt update    sudo apt install ~nros-foxy-rqt*</code></pre><ul><li>通过remapping 给节点重命名：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 run turtlesim turtle_teleop_key --ros-args --remap turtle1/cmd_vel:=turtle2/cmd_vel</code></pre><h2 id="二、节点相关指令"><a href="#二、节点相关指令" class="headerlink" title="二、节点相关指令"></a>二、节点相关指令</h2><ul><li>启动节点程序：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 run <package_name> <executable_name>    ros2 run turtlesim turtlesim_node</code></pre><ul><li>列出节点：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 node list</code></pre><ul><li>重映射：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle</code></pre><ul><li>查看节点信息：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 node info <node_name>    ros2 node info /my_turtle</code></pre><h2 id="三、话题相关指令"><a href="#三、话题相关指令" class="headerlink" title="三、话题相关指令"></a>三、话题相关指令</h2><ul><li>列出所有话题：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 topic list    ros2 topic list -t    #显示消息数据类型</code></pre><ul><li>返回话题数据：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 topic echo <topic_name>    ros2 topic echo /turtle1/cmd_vel</code></pre><ul><li>显示话题信息：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 topic info /turtle1/cmd_vel</code></pre><ul><li>查看话题中消息的具体数据结构：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 interface show geometry_msgs/msg/Twist</code></pre><ul><li>发布话题消息：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 topic pub <topic_name> <msg_type> '<args>'    #这里的 ‘<args>’就是具体的消息内容啦，我们需要使用YAML的语法来描述，比如要发布速度指令Twist:    #–once表示这个消息只发布一次就退出。    ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 2.0, z: 2.0}, angular: {x: 0, y: 0, z: 2.0}}"    #持续发布    #–rate参数就表示频率啦，单位是hz    ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}"</code></pre><ul><li>查看话题消息的发布频率：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 topic hz /turtle1/pose</code></pre><h2 id="四、服务相关指令"><a href="#四、服务相关指令" class="headerlink" title="四、服务相关指令"></a>四、服务相关指令</h2><ul><li>列出服务：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 service list    ros2 service list -t</code></pre><ul><li>查看服务的数据结构：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 service type <service_name></code></pre><ul><li>查找提供某类型数据的所有服务:</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 service find <type_name>        ros2 service find std_srvs/srv/Empty</code></pre><ul><li>查看服务数据类型的具体结构:</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 interface show <type_name>.srv    ros2 interface show std_srvs/srv/Empty.srv</code></pre><ul><li>通过终端发送服务请求：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 service call <service_name> <service_type> <arguments>    ros2 service call /clear std_srvs/srv/Empty    ros2 service call /spawn turtlesim/srv/Spawn "{x: 2, y: 2, theta: 0.2, name: ''}"</code></pre><h2 id="五、参数服务相关指令"><a href="#五、参数服务相关指令" class="headerlink" title="五、参数服务相关指令"></a>五、参数服务相关指令</h2><ul><li>查看参数列表：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 param list</code></pre><ul><li>获取参数值：</li></ul><pre><code>    ros2 param get &lt;node_name&gt; &lt;parameter_name&gt;    ros2 param get /turtlesim background_g</code></pre><ul><li>设置参数值：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 param set <node_name> <parameter_name> <value>    ros2 param set /turtlesim background_r 150</code></pre><ul><li>保存参数：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 param dump <node_name>    ros2 param dump /turtlesim</code></pre><ul><li>加载参数文件：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 run <package_name> <executable_name> --ros-args --params-file <file_name>    ros2 run turtlesim turtlesim_node --ros-args --params-file ./turtlesim.yaml</code></pre><h2 id="六、Action相关指令"><a href="#六、Action相关指令" class="headerlink" title="六、Action相关指令"></a>六、Action相关指令</h2><ul><li>查看action列表：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 action list    ros2 action list -t</code></pre><ul><li>查看action信息：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 action info /turtle1/rotate_absolute</code></pre><ul><li>查看action数据类型：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 interface show turtlesim/action/RotateAbsolute.action</code></pre><ul><li>命令行发送action目标：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 action send_goal <action_name> <action_type> <values>    #<values>同样是YAML格式描述的数据。发送一个试试：    ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute "{theta: 1.57}"    #如果先要看到action中的周期反馈，以上命令还需要加一个–feedback参数：    ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute "{theta: -1.57}" --feedback</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> ROS2, Bash。 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用ZYNQ实现单LUT内容的动态修改（二）PS端动态修改LUT内容，软件部分，Vitis操作</title>
      <link href="/myblogs/2020/10/23/blog4-lut-nei-rong-du-qu-2/"/>
      <url>/myblogs/2020/10/23/blog4-lut-nei-rong-du-qu-2/</url>
      
        <content type="html"><![CDATA[<p>该系统的软件部分使用Xilinx Vitis平台进行实现，操作方法类似于之前版本的SDK，不同的是Vitis中的硬件平台要自己手动导入，其余编译调试大体相同。<br><a id="more"></a></p><h2 id="一，摘要"><a href="#一，摘要" class="headerlink" title="一，摘要"></a>一，摘要</h2><p>该篇博客主要记录软件端的整个流程，主要依据官方给出的HW_ICAP驱动库进行开发。具体硬件原理方面的知识不做太多介绍。有需要的话可以参考官方的一些手册。</p><h2 id="二，程序流程"><a href="#二，程序流程" class="headerlink" title="二，程序流程"></a>二，程序流程</h2><p>程序循环执行以下四种操作，</p><ol><li>输入FAR寄存器值，读取对应地址的数据帧。</li><li>输入要修改的LUT的位置，该位置可通过生成硬件时的Layout找出。</li><li>输入要修改LUT的新数据。将修改过的数据帧写入FPGA内部。</li><li>重新读出数据帧，与写入的数据帧进行对比，完全一致即返回修改成功，返回操作1。<h2 id="三，工程的建立与调试"><a href="#三，工程的建立与调试" class="headerlink" title="三，工程的建立与调试"></a>三，工程的建立与调试</h2>主要记录一些关键步骤！<h3 id="第一步，导入上篇博客生成的硬件平台"><a href="#第一步，导入上篇博客生成的硬件平台" class="headerlink" title="第一步，导入上篇博客生成的硬件平台"></a>第一步，导入上篇博客生成的硬件平台</h3>导入上篇博客工程目录下的xsa文件。<br><img src="https://img-blog.csdnimg.cn/20200225213224296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><br>接下来编译该硬件平台。<br><img src="https://img-blog.csdnimg.cn/202002252136222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><h3 id="第二步，导入并编译修改单LUT的程序"><a href="#第二步，导入并编译修改单LUT的程序" class="headerlink" title="第二步，导入并编译修改单LUT的程序"></a>第二步，导入并编译修改单LUT的程序</h3>导入.\src\vitis\目录下的C语言源文件，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200225220537262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt></li></ol><p>接下来需要注意官方的驱动有个BUG，针对于ZYNQ系列的器件，其DeviceIDCode并没有在7系列里面包含，这就使得在执行XHwIcap_CfgInitialize（）函数时出错，所以在此处要将其ID号改成7系列列表中有的ID号，如下图239行所示。<br><img src="https://img-blog.csdnimg.cn/20200225220055114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt></p><h3 id="第三步，调试工程。"><a href="#第三步，调试工程。" class="headerlink" title="第三步，调试工程。"></a>第三步，调试工程。</h3><p>右击工程选择Debug As/DebugConfiguration,然后设置如下图，点击调试。<br><img src="https://img-blog.csdnimg.cn/20200225221150746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><br>此时我们把top2.bit文件下载到FPGA部分，可以看到其LUT的输出内容如下图，<br><img src="https://img-blog.csdnimg.cn/20200225221001606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><br>通过串口助手输入FAR地址字段，对FPGA内部该地址的配置帧进行读取。<br><img src="https://img-blog.csdnimg.cn/20200225221744292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><br>截取部分读出的配置数据如下图所示，可在转换过后的rbt文件中找到该配置帧的数据。<br>我们需要操作的目标LUT的前1/4配置数据为下图中0x55550000这一数据，我们此时要对其进行更改。<br><img src="https://img-blog.csdnimg.cn/20200225221900112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><br>首先我们要输入该LUT数据在该帧数据中的位置08（此位置可以通过layout看出来）。<br><img src="https://img-blog.csdnimg.cn/20200225222329137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><br>进一步输入要修改成的数据，如下图所示，正常情况下返回Success即为写入成功。<br><img src="https://img-blog.csdnimg.cn/20200225222354507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><br>最终我们再来看一下该LUT输出的波形如下，可以看出其内部数据已经被修改了。<br><img src="https://img-blog.csdnimg.cn/2020022522262754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt></p><h2 id="四、中间遇到的问题"><a href="#四、中间遇到的问题" class="headerlink" title="四、中间遇到的问题"></a>四、中间遇到的问题</h2><ol><li>读帧数据时显示不完整，后小部分出现0xfffffffd,此种情况是由于AXI_ICAP ip的读FIFO容量设置太小造成的，中间会有部分数据缺失。解决办法，调大读FIFO的容量。</li><li>写帧数据时写不进去，经排查发现为设置正确的DeviceID号，改正后问题解决。</li><li>配置数据与LUT实际存储内容的映射关系还没来得及整清楚，看后面是否用得到。<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2>基本打通了单LUT读写的底层通路，为后面重构控制器的设计打下了基础。考虑通过云端等接口实现远程LUT内容的读写等操作，基于此可实现FPGA内部错误的自修复，高效重构任务的执行等高级功能。<h2 id="六、附程序代码如下"><a href="#六、附程序代码如下" class="headerlink" title="六、附程序代码如下"></a>六、附程序代码如下</h2></li></ol><pre class=" language-lang-c"><code class="language-lang-c">#include <stdlib.h>#include <stdio.h>#include <string.h>#include "xparameters.h"#include "xil_printf.h"#include "xil_cache.h"#include "ff.h"#include "xdevcfg.h"#include "xhwicap.h"#include "xil_io.h"#include "xil_types.h"#define PYNQ#define FRAME_WORDS_NUM    202// Parameters for Partial Reconfiguration#ifdef PYNQ#define READ_FRAME_SIZE 30#define WRITE_FRAME_SIZE 91#define PARTIAL_MULT_ADDR   0x200000#define PARTIAL_ADDER_ADDR   0x300000#define PARTIAL_BLANK_ADDR   0x400000#define PARTIAL_MULT_BITFILE_LEN  0xC66F // in number of words#define PARTIAL_ADDER_BITFILE_LEN  0xC66F // in number of words#define PARTIAL_BLANK_BITFILE_LEN  0xC66F // in number of words#endif// Turn on/off Debug messages#ifdef DEBUG_PRINT#define  debug_printf  xil_printf#else#define  debug_printf(msg, args...) do {  } while (0)#endif// Read function for STDINextern char inbyte(void);// Driver Instantiationsstatic XDcfg_Config *XDcfg_0;XDcfg DcfgInstance;XDcfg *DcfgInstPtr;static XHwIcap HwIcap;    // The instance of the HWICAP deviceXHwIcap *HwIcapInstPtr;uint32_t read_FrameBuffer[FRAME_WORDS_NUM];uint32_t read_FrameBuffer_verify[FRAME_WORDS_NUM];unsigned char uartBuffer[16];uint32_t addr_word;    //FAR Word.uint32_t new_word;    //The word to be writen to lut;uint32_t lut_index;    //int XHwIcap_DeviceReadFrame1(XHwIcap *InstancePtr, uint32_t far_word , u32 *FrameBuffer){    u32 Packet;    u32 Data;    u32 TotalWords;    int Status;    u32 WriteBuffer[WRITE_FRAME_SIZE];    u32 Index = 0;    u32 NumNoops;    Xil_AssertNonvoid(InstancePtr != NULL);    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);    Xil_AssertNonvoid(FrameBuffer != NULL);    /*     * DUMMY and SYNC     */    WriteBuffer[Index++] = XHI_DUMMY_PACKET;    WriteBuffer[Index++] = XHI_BUS_WTH_PACKET;    WriteBuffer[Index++] = XHI_BUS_DET_PACKET;    WriteBuffer[Index++] = XHI_DUMMY_PACKET;    WriteBuffer[Index++] = XHI_SYNC_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    /*     * Reset CRC     */    Packet = XHwIcap_Type1Write(XHI_CMD) | 1;    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = XHI_CMD_RCRC;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    /*     * Setup CMD register to read configuration     */    Packet = XHwIcap_Type1Write(XHI_CMD) | 1;    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = XHI_CMD_RCFG;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    /*     * Setup FAR register.     */    Packet = XHwIcap_Type1Write(XHI_FAR) | 1;    Data = far_word;    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = Data;    /*     * Setup read data packet header.     * The frame will be preceeded by a dummy frame, and we need to read one     * extra word for V4 and V5 devices.     */    switch (InstancePtr->DeviceFamily) {        case DEVICE_TYPE_7SERIES :                TotalWords = InstancePtr->WordsPerFrame << 1;                NumNoops = 32;                break;        case DEVICE_TYPE_ULTRA :            TotalWords = (InstancePtr->WordsPerFrame << 1) + 10;            NumNoops = 64;                break;        case DEVICE_TYPE_ULTRA_PLUS :            TotalWords = (InstancePtr->WordsPerFrame << 1) + 25;            NumNoops = 64;                break;        default:            return XST_FAILURE;    }    /*     * Create Type one packet     */    Packet = XHwIcap_Type1Read(XHI_FDRO);    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = 0x48000000 | TotalWords;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    for(unsigned int i = 0; i < NumNoops; i++) {        WriteBuffer[Index++] = XHI_NOOP_PACKET;    }    /*     * Write the data to the FIFO and initiate the transfer of data     * present in the FIFO to the ICAP device     */    Status = XHwIcap_DeviceWrite(InstancePtr, (u32 *)&WriteBuffer[0],            Index);    if (Status != XST_SUCCESS)  {        return XST_FAILURE;    }    /*     * Wait till the write is done.     */    while (XHwIcap_IsDeviceBusy(InstancePtr) != FALSE);    /*     * Read the frame of the data including the NULL frame.     */    Status = XHwIcap_DeviceRead(InstancePtr, FrameBuffer, TotalWords);    if (Status != XST_SUCCESS)  {        return XST_FAILURE;    }    /*     * Send DESYNC command     */    Status = XHwIcap_CommandDesync(InstancePtr);    if (Status != XST_SUCCESS)  {        return XST_FAILURE;    }    return XST_SUCCESS;};int XHwIcap_DeviceWriteFrame1(XHwIcap *InstancePtr, u32 far_word,                u32 *FrameData){    u32 Packet;    u32 Data;    u32 TotalWords;    int Status;    u32 WriteBuffer[READ_FRAME_SIZE];    u32 Index =0;    Xil_AssertNonvoid(InstancePtr != NULL);    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);    Xil_AssertNonvoid(FrameData != NULL);    /*     * DUMMY and SYNC     */    WriteBuffer[Index++] = XHI_DUMMY_PACKET;    WriteBuffer[Index++] = XHI_SYNC_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    /*     * Reset CRC     */    Packet = XHwIcap_Type1Write(XHI_CMD) | 1;    Data = XHI_CMD_RCRC;    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = Data;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    /*     * Bypass CRC     */    /*     * ID register     */    Packet = XHwIcap_Type1Write(XHI_IDCODE) | 1;    Data = InstancePtr->DeviceIdCode;    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = Data;    /*     * Setup FAR     */    Packet = XHwIcap_Type1Write(XHI_FAR) | 1;    Data = far_word;    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = Data;    /*     * Setup CMD register - write configuration     */    Packet = XHwIcap_Type1Write(XHI_CMD) | 1;    Data = XHI_CMD_WCFG;    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = Data;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    /*     * Setup Packet header.     */    TotalWords = InstancePtr->WordsPerFrame << 1;    if (TotalWords < XHI_TYPE_1_PACKET_MAX_WORDS)  {        /*         * Create Type 1 Packet.         */        Packet = XHwIcap_Type1Write(XHI_FDRI) | TotalWords;        WriteBuffer[Index++] = Packet;    }    else {        /*         * Create Type 2 Packet.         */        Packet = XHwIcap_Type1Write(XHI_FDRI);        WriteBuffer[Index++] = Packet;        Packet = XHI_TYPE_2_WRITE | TotalWords;        WriteBuffer[Index++] = Packet;    }    /*     * Write the Header data into the FIFO and intiate the transfer of     * data present in the FIFO to the ICAP device     */    Status = XHwIcap_DeviceWrite(InstancePtr, (u32 *)&WriteBuffer[0], Index);    if (Status != XST_SUCCESS)  {        return XST_FAILURE;    }    /*     * Write the modified frame data.     */    Status = XHwIcap_DeviceWrite(InstancePtr,                (u32 *) &FrameData[InstancePtr->WordsPerFrame],                InstancePtr->WordsPerFrame);    if (Status != XST_SUCCESS) {        return XST_FAILURE;    }    /*     * Write out the pad frame. The pad frame was read from the device     * before the data frame.     */    Status = XHwIcap_DeviceWrite(InstancePtr, (u32 *) &FrameData[0],                    InstancePtr->WordsPerFrame);    if (Status != XST_SUCCESS) {        return XST_FAILURE;    }    /* Add CRC */    Index = 0;    Packet = XHwIcap_Type1Write(XHI_CMD) | 1;    Data = XHI_CMD_RCRC;    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = Data;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    /* Park the FAR */    Packet = XHwIcap_Type1Write(XHI_FAR) | 1;    Data = XHwIcap_SetupFar(0, 0, 3, 33, 0);    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] =  Data;    /* Add CRC */    Packet = XHwIcap_Type1Write(XHI_CMD) | 1;    Data = XHI_CMD_RCRC;    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = Data;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    /*     * Intiate the transfer of data present in the FIFO to     * the ICAP device     */    Status = XHwIcap_DeviceWrite(InstancePtr, &WriteBuffer[0], Index);    if (Status != XST_SUCCESS)  {        return XST_FAILURE;    }    /*     * Send DESYNC command     */    Status = XHwIcap_CommandDesync(InstancePtr);    if (Status != XST_SUCCESS) {        return XST_FAILURE;    }    return XST_SUCCESS;};u32 getWord (){    unsigned char byte;    int digitIndex;    u32 far_word;    while(1){        byte = 0x00;        digitIndex = 0;        //get bytes from uart until RETURN is entered        while(byte != 0x0d){            byte = inbyte();            uartBuffer[digitIndex] = byte;            xil_printf("%x", byte);            digitIndex++;        }        xil_printf("\r\n");        if(digitIndex==5)        {            far_word = uartBuffer[0]<<24 | uartBuffer[1]<<16 |uartBuffer[2]<<8 | uartBuffer[3];            return far_word;        }        else        {            digitIndex =0 ;            break;        }    }}u32 getByte (){    unsigned char byte;    int digitIndex;    u32 data;    while(1){        byte = 0x00;        digitIndex = 0;        //get bytes from uart until RETURN is entered        while(byte != 0x0d){            byte = inbyte();            uartBuffer[digitIndex] = byte;            xil_printf("%x\r\n", byte);            digitIndex++;        }        if(digitIndex==2)        {            data = uartBuffer[0];            return data;        }    }}int main(){    int Status;    int i;    int equal_number;    XHwIcap_Config *ConfigPtr;    // Flush and disable Data Cache    Xil_DCacheDisable();    // Invalidate and enable Data Cache    Xil_DCacheEnable();    // Initialize Device Configuration Interface    DcfgInstPtr = &DcfgInstance;    XDcfg_0 = XDcfg_LookupConfig(XPAR_XDCFG_0_DEVICE_ID) ;    Status =  XDcfg_CfgInitialize(DcfgInstPtr, XDcfg_0, XDcfg_0->BaseAddr);    if (Status != XST_SUCCESS) {        return XST_FAILURE;    }    // Deselect PCAP as the configuration device as we are going to use the ICAP    XDcfg_ClearControlRegister(DcfgInstPtr, XDCFG_CTRL_PCAP_PR_MASK);    ConfigPtr = XHwIcap_LookupConfig(XPAR_AXI_HWICAP_0_DEVICE_ID);    if (ConfigPtr == NULL) {        return XST_FAILURE;    }    HwIcapInstPtr = &HwIcap;    Status = XHwIcap_CfgInitialize(HwIcapInstPtr, ConfigPtr,                ConfigPtr->BaseAddress);    if (Status != XST_SUCCESS) {        return XST_FAILURE;    }    HwIcapInstPtr->DeviceIdCode = 0x23727093;    XHwIcap_Reset(HwIcapInstPtr);    print("HWICAP Initialized\r\n");    while(1)    {        equal_number=0;        print("Please input the far words!\r\n");        addr_word = getWord();        Status = XHwIcap_DeviceReadFrame1(HwIcapInstPtr, addr_word,&read_FrameBuffer[0]);        XHwIcap_Reset(HwIcapInstPtr);        if (Status != XST_SUCCESS) {            print("Read Lut Failure\r\n");            return XST_FAILURE;        }        else if(Status == XST_SUCCESS)        {            for(i=0;i<FRAME_WORDS_NUM;i++)                xil_printf("%x\r\n",read_FrameBuffer[i]);        }        print("Please input the number of the lut:\r\n");        lut_index = getByte();        print("Please input the new data of the lut:\r\n");        new_word = getWord();        read_FrameBuffer[(101 + lut_index)] = new_word;        Status = XHwIcap_DeviceWriteFrame1(HwIcapInstPtr, addr_word, &read_FrameBuffer[1]);        XHwIcap_Reset(HwIcapInstPtr);        if (Status != XST_SUCCESS) {            print("Write Lut Failure\r\n");            return XST_FAILURE;        }        Status = XHwIcap_DeviceReadFrame1(HwIcapInstPtr, addr_word,read_FrameBuffer_verify);        if (Status != XST_SUCCESS) {            print("Read Lut Failure\r\n");            return XST_FAILURE;        }        for(i=0;i<FRAME_WORDS_NUM;i++)        {            if(read_FrameBuffer_verify[i] == read_FrameBuffer[i])            {                equal_number ++;            }        }        if(equal_number != 202)            print("Write Lut Failure!\r\n");        else            print("Write Lut Success!\r\n");    }    return 0;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> FPGA, ZYNQ, Vitis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用ZYNQ实现单LUT内容的动态修改（一）PL端OOC设计流程</title>
      <link href="/myblogs/2020/10/23/blog3-lut-nei-rong-du-qu-1/"/>
      <url>/myblogs/2020/10/23/blog3-lut-nei-rong-du-qu-1/</url>
      
        <content type="html"><![CDATA[<p>本文主要用于记录作者本人实现ZYNQ动态修改LUT内容过程中主要参考的资料，实现的步骤，遇到的问题等。主要参考的文章链接如下：<a href="https://cloud.tencent.com/developer/article/1528881，其中该工作大部分的原理部分该篇博客都有介绍，本篇博客不再赘述。" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1528881，其中该工作大部分的原理部分该篇博客都有介绍，本篇博客不再赘述。</a><br><a id="more"></a></p><h2 id="一，摘要"><a href="#一，摘要" class="headerlink" title="一，摘要"></a>一，摘要</h2><p>主要介绍一下<strong>使用Vivado进行部分动态重构系统的开发流程</strong>，<strong>AXI_HWICAP IP基本的使用方法</strong>，以及<strong>通过ARM部分实现LUT内容动态修改的程序流程(此部分见下篇博客)</strong>。</p><h2 id="二，系统框图"><a href="#二，系统框图" class="headerlink" title="二，系统框图"></a>二，系统框图</h2><p><img src="https://img-blog.csdnimg.cn/20200225180357207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt="系统框图"><br>系统结构主要如上图，其中LUT的读写操作由PS端的程序控制，通过PC端的串口助手可以观察读取的配置帧数据，设置要修改的LUT位置以及修改后的LUT中的新数据。</p><h2 id="三，PL工程的创建，综合，布局布线。"><a href="#三，PL工程的创建，综合，布局布线。" class="headerlink" title="三，PL工程的创建，综合，布局布线。"></a>三，PL工程的创建，综合，布局布线。</h2><p>考虑到调试过程中可能要多次设置目标LUT的初始值来搞清楚bitstream中数据与LUT中数据的映射关系，为了<strong>提高该系统的编译调试效率，本文针对目标操作的LUT采取局部动态重构的设计方法</strong>。实际应用中不采用部分重构设计流程也可以对LUT进行动态读写。<br>以下是本次设计使用Vivado进行部分重构系统开发的整体流程：</p><ol><li>使用Vivado创建整个设计，将部分重构模块保留为空模块。综合工程生成静态设计的.dcp文件(如top_syn_static.dcp)。</li><li>综合部分重构模块的源文件，生成对应的.dcp文件(如：pr_lut_syn.dcp)。</li><li>打开第一步生成的top_syn_static.dcp，读入第二步生成的pr_lut_syn.dcp，设置重构属性，保存设计点。</li><li>为重构模块指定重构区域，读入约束文件。</li><li>优化，布局，布线，保存设计点。</li><li>生成bitstream文件，及ila调试相关文件。</li><li>将重构模块清除保留为黑盒，将其他部分在布局布线后的级别上保存其设计点。</li><li>打开上一步保存的设计点，读入新的重构模块，优化，布局布线，保存设计点，生成bitstream等。</li><li>使用pr_verify指令对生成的bitstream进行验证。<h3 id="第一步，创建设计。"><a href="#第一步，创建设计。" class="headerlink" title="第一步，创建设计。"></a>第一步，创建设计。</h3>可直接在给出的工程目录下面执行脚本自动创建，综合，以及硬件的导出。在工程目录下执行以下代码(windows下需要在Vivado的命令行下操作)：<pre class=" language-lang-javascript"><code class="language-lang-javascript">source ./tcl/step1_create_project.tcl</code></pre>具体工程文件结构如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200225173307967.png" alt="工程结构"><br>其中原理图部分如下：<br><img src="https://img-blog.csdnimg.cn/20200225173451606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt="原理图"><br>这一步我们要<strong>用到的文件为.\vivado\lut_modify.runs\synth_1\top.dcp，我们需要将此文件复制到.\checkpoints\synth\static\路径下</strong>，便于后续操作。<br>当然也可以自己手动来创建工程，编写相关文件。<h3 id="第二步，综合重构模块"><a href="#第二步，综合重构模块" class="headerlink" title="第二步，综合重构模块"></a>第二步，综合重构模块</h3>直接执行脚本文件即可，脚本代码如下：<pre class=" language-lang-javascript"><code class="language-lang-javascript">read_verilog ./src/rms/pr_lut1/pr_lut.vsynth_design -mode out_of_context -flatten_hierarchy rebuilt -top pr_lut -part xc7z020clg400-1write_checkpoint ./checkpoints/synth/rms/pr_lut1.dcpclose_designclose_project</code></pre>以下是重构模块的verilog代码，该模块例化一个内部的固定位置的LUT，便于我们以后寻址更改其内部内容：<pre class=" language-lang-verilog"><code class="language-lang-verilog">timescale 1ns/1ps //*******************//DEFINE MODULE PORT//*******************module  pr_lut   (               input           clk  ,          input           rst  ,          input   [5:0]   din  ,          output  reg     dout                     ) ;//*********************//INNER SIGNAL DECLARATION//*********************//REGSreg [5:0] din_ff ;//WIRESwire  dout_pre ;//*********************//MAIN CORE//********************* always @(posedge clk or posedge rst) begin  if (rst == 1'b1) begin      din_ff <= 'd0 ;  end  else begin      din_ff <= din ;  endendalways @(posedge clk or posedge rst) begin  if (rst == 1'b1) begin      dout <= 'd0 ;  end  else begin      dout <= dout_pre ;  endend// 0001 0010 0011(* DONT_TOUCH= "TRUE" *) (*BEL="D6LUT",LOC="SLICE_X57Y53"*)    LUT6 #(    .INIT(64'h1234123412341234)  // Specify LUT Contents  ) LUT6_inst_D_right (    .O(dout_pre),   // LUT general output    .I0(din_ff[0]), // LUT input    .I1(din_ff[1]), // LUT input    .I2(din_ff[2]), // LUT input    .I3(din_ff[3]), // LUT input    .I4(din_ff[4]), // LUT input    .I5(din_ff[5])  // LUT input );//*********************endmodule</code></pre></li></ol><p>该步操作主要生成的文件如下图,后面可用不同lut初始值的rm来创建完整设计，方便在bitstream文件中找到目标lut配置数据的位置及内容。便于分析bitstream配置数据同实际LUT中数据的映射关系：<br><img src="https://img-blog.csdnimg.cn/20200225180557292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt="rms"></p><h3 id="第三步，打开设计点，读入重构模块，划分重构区域"><a href="#第三步，打开设计点，读入重构模块，划分重构区域" class="headerlink" title="第三步，打开设计点，读入重构模块，划分重构区域"></a>第三步，打开设计点，读入重构模块，划分重构区域</h3><p>执行以下脚本</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">open_checkpoint ./checkpoints/synth/static/top.dcpread_checkpoint -cell pr_lut_0 ./checkpoints/synth/rms/pr_lut1.dcpset_property HD.RECONFIGURABLE 1 [get_cells pr_lut_0]  write_checkpoint ./checkpoints/synth/top_link_lut.dcp -force #划分重构区域。startgroupcreate_pblock pblock_pr_lut_0resize_pblock pblock_pr_lut_0 -add {SLICE_X54Y50:SLICE_X59Y59 RAMB18_X3Y20:RAMB18_X3Y23 RAMB36_X3Y10:RAMB36_X3Y11}add_cells_to_pblock pblock_pr_lut_0 [get_cells [list pr_lut_0]] -clear_locsendgroup</code></pre><p>其中为重构模块划分重构区域手动操作如下图，然后在layout上面绘制相应的重构区域即可，注意：此例中由于指定了LUT的位置信息，所以重构区域必须覆盖到该LUT的物理区域。<br><img src="https://img-blog.csdnimg.cn/20200225181803384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt="划分重构区域"><br>此例中划分的重构区域如下：<br><img src="https://img-blog.csdnimg.cn/20200225182306433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt="重构区域"></p><h3 id="第四步，优化，布局布线，保存设计点，生成-bit及-rbt文件。"><a href="#第四步，优化，布局布线，保存设计点，生成-bit及-rbt文件。" class="headerlink" title="第四步，优化，布局布线，保存设计点，生成.bit及.rbt文件。"></a>第四步，优化，布局布线，保存设计点，生成.bit及.rbt文件。</h3><p>直接执行以下命令：</p><pre class=" language-lang-bash"><code class="language-lang-bash">opt_design place_design route_designwrite_checkpoint -force ./checkpoints/implement/top_route_design.dcp write_checkpoint -force -cell pr_lut_0 ./checkpoints/implement/pr_lut_instance_route_design.dcpwrite_bitstream  -raw_bitfile ./bitstreams/top1 -forcewrite_debug_probes -force ./bitstreams/top</code></pre><p>执行上述命令后可以观察到器件已经完成布局布线，此时可生成对应的bitstream文件及部分bitstream文件。我们可通过生成的top.rbt来分析top.bit的结构，（<strong>top.rbt为top.bit的二进制asii格式表示，可通过python脚本来将rbt文件转换为16进制格式表示数据并保存为txt文件，后续我们从器件中读配置数据的时候要与之进行对比，来验证读操作的正确性</strong>）<br><img src="https://img-blog.csdnimg.cn/20200225184904323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt="布局布线结果"></p><h3 id="第五步，保存静态设计。"><a href="#第五步，保存静态设计。" class="headerlink" title="第五步，保存静态设计。"></a>第五步，保存静态设计。</h3><p>脚本命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">update_design -cell pr_lut_0 -black_boxlock_design -level routingwrite_checkpoint -force ./checkpoints/routed/static_route_design.dcpupdate_design -buffer_ports -cell pr_lut_0place_designroute_designwrite_checkpoint -force ./checkpoints/implement/top_route_design.dcpclose_project</code></pre><h3 id="第六步，读入新的重构模块，生成的完整bit文件及部分bit文件。"><a href="#第六步，读入新的重构模块，生成的完整bit文件及部分bit文件。" class="headerlink" title="第六步，读入新的重构模块，生成的完整bit文件及部分bit文件。"></a>第六步，读入新的重构模块，生成的完整bit文件及部分bit文件。</h3><p>脚本和上面操作多有重复，这里不再给出。<br><strong>本操作的意义在于利用前面保存过的静态设计，载入新的重构模块进行综合，布局布线，大大减少了整个工程综合，布局布线的时间成本。</strong><br>针对此次设计任务需求，需要多次更改目标LUT的初始值，采用此种设计流程能够大大减少后期bitstream文件的生成时间，而不必牵一发而动全身，每次都浪费这么长的时间来进行类似的操作。</p><h3 id="第七步，验证两个设计是否兼容。"><a href="#第七步，验证两个设计是否兼容。" class="headerlink" title="第七步，验证两个设计是否兼容。"></a>第七步，验证两个设计是否兼容。</h3><p>脚本命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">pr_verify -initial ./checkpoints/implement/top_route_design.dcp  -additional {./checkpoints/implement/top_route_design2.dcp }close_project</code></pre><p>验证结果如下图<br><img src="https://img-blog.csdnimg.cn/20200225195512172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt="验证结果"><br>至此整个重构系统基于Vivado的脱离上下文的设计流程结束。</p><h2 id="四、AXI-HWICAP相关信息"><a href="#四、AXI-HWICAP相关信息" class="headerlink" title="四、AXI_HWICAP相关信息"></a>四、AXI_HWICAP相关信息</h2><p>相关寄存器如下表：<br><img src="https://img-blog.csdnimg.cn/20200225201034277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt="reg1"><br><img src="https://img-blog.csdnimg.cn/20200225201056262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><br><img src="https://img-blog.csdnimg.cn/20200225201138870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><br>读写配置：<br>1)    将bitstream写进写FIFO寄存器进行配置。<br>2)    从读FIFO寄存器读取配置bitstream。<br>3)    向CR寄存器写值去启动bitstream的读取或写入，控制寄存器决定了数据传输的方向。向控制寄存器写入0x00000001开始写配置。写0x00000002开始读配置。<br>4)    状态寄存器的Done位表明了ICAPEn接口是否处于忙碌状态，并不代表读配置或写配置是否成功完成。<br>5)    在成功进行读或者写配置之后硬件清零CR寄存器。<br>6)    在CR寄存器未被清零的情况下，软件不能初始化另一个读或写配置操作。</p><p>精简模式下写序列：<br>1)    将指令写进写FIFO寄存器进行配置。<br>2)    向控制寄存器写控制字初始化写指令。<br>3)    成功完成配置后硬件清零控制寄存器位。<br>4)    向写FIFO寄存器写入第二个指令，写控制字执行向ICAPEn端口的写操作。<br>5)    继续执行上述操作直到所有指令被写到ICAPEn端口。</p><p>中止：<br>1)    向控制寄存器写控制字开始bitstream读写。<br>2)    将bitstream写入到FIFO寄存器执行配置，从读FIFO寄存器获取读取到的bitstream。<br>3)    向控制寄存器的第五位写1来执行中止。<br>4)    状态寄存器的Done位显示了ICAPEn端口是否正处于忙碌状态，不表示读，写操作成功完成。<br>5)    在成功执行中止操作后硬件清零控制寄存器位。<br>6)    在CR寄存器未被清零的情况下，软件不能初始化另一个读或写配置操作。</p><p>注意：<br>1)    <strong>帧是配置数据允许被读或写的最小粒度。</strong><br>2)    <strong>修改单个LUT内容必须读出整帧，修改后再将整帧数据读入。</strong></p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇博客主要记录了使用Vivado工具进行脱离上下文(Out Of Context)方式进行开发的流程。<strong>以本篇生成的硬件系统为基础，可以进一步通过PS端的软件编程来实现对目标LUT的内容进行修改，亦可通过软件来为PR区域加载不同的重构模块来实现FPGA内部电路的动态重构。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> FPGA, ZYNQ, LUT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adam论文翻译</title>
      <link href="/myblogs/2020/08/13/blog2-adam-lun-wen-fan-yi/"/>
      <url>/myblogs/2020/08/13/blog2-adam-lun-wen-fan-yi/</url>
      
        <content type="html"><![CDATA[<p>本文为Adam算法原论文的翻译。<br><a id="more"></a></p><h2 id="第一部分：引言"><a href="#第一部分：引言" class="headerlink" title="第一部分：引言"></a>第一部分：引言</h2><p>​    基于随机梯度的优化问题在许多科学和工程领域具有重要的实际意义。这些领域中的许多问题都可以归结为某个标量参数化目标函数的优化问题，这些目标函数要求对其参数进行最大化或最小化。如果函数的参数是可微的，梯度下降法是一种比较有效的优化方法，因为计算一阶偏导数w.r.t.的所有参数都与计算函数的计算复杂度相同。通常，目标函数是随机的。在这种情况下，可以用多个随机子函数组成的梯度函数或多个梯度子函数组成。SGD被证明是一种高效、有效的优化方法，在许多机器学习成功案例中起着核心作用，例如深度学习的最新进展（Deng等人，2013；Krizhevsky等人，2012；Hinton&amp;Salakhutdinov，2006；Hinton et al.，2012a；Graves et al.，2013）。目标也可能有数据子采样以外的其他噪声源，如辍学（Hinton等人，2012b）正则化。对于所有这些噪声目标，需要有效的随机优化技术。本文主要研究具有高维参数空间的随机目标优化问题。在这些情况下，高阶优化方法不适合，本文的讨论将局限于一阶方法。</p><p>​    我们提出了Adam，一种只需要一阶梯度且内存需求很少的高效随机优化方法。该方法根据梯度的一阶矩和二阶矩的估计来计算不同参数的个体自适应学习率；Adam的名字来源于自适应矩估计。我们的方法结合了最近流行的两种方法的优点：AdaGrad（Duchi et al.，2011）和RMSProp（Tieleman&amp;Hinton，2012），这两种方法在在线和非平稳环境下工作良好；第5节阐明了这些方法和其他随机优化方法的重要联系。Adam的一些优点是参数更新的大小对梯度的重定标是不变的，它的步长是由步长超参数近似限定的，它不需要一个平稳的目标，它与稀疏梯度一起工作，并且它自然地执行一种步长退火的形式。</p><hr><p><strong>算法1：</strong> $g_t^2$代表元素平方$g_t \bigodot g_t$，被测试机器学习问题的良好的默认设置参数为$\alpha = 0.001, \beta_1=0.9,\beta_2=0.99$ 以及$\epsilon=10^{-8}$。对向量所有的操作都是基于元素的。对于$\beta_1^t 与\beta_2^t$表示$\beta_1 \beta_2$的t次方。</p><hr><p>$ \bf{Require: } \quad\alpha:\; Stepsize$</p><p>$\bf{Require:} \quad\beta_1,\beta_2\in[0,1): \;  Exponential\;decay\; rates\; for\; the\; moment\; estimates$</p><p>$ \bf{Require: } \quad f(\theta):\; Stochastic\; objective\; function\; with\; parameters\; \theta $</p><p>$ \bf{Require: } \quad\theta_0:\; Initial\; parameter\; vector $</p><p>$\qquad m_0 \leftarrow 0 (Initialize\; 1^{st} \;moment \; vector) $</p><p>$\qquad v_0 \leftarrow 0 (Initialize\; 2^{nd} \;moment \; vector) $</p><p>$\qquad t \leftarrow 0 (Initialize\; timestep) $</p><p>$\qquad \bf{while} \;\theta_t \; not\; converged \; \bf{do} $</p><p>$\qquad \qquad t \leftarrow t+1 $</p><p>$\qquad \qquad g_t \leftarrow  \nabla_{\theta}f_t(\theta_t-1) \;(Get\; gradients\; w.r.t.\; stochastic\; objective\; at\; timestep\; t) $</p><p>$\qquad \qquad m_t \leftarrow \beta_1 \cdot m_{t-1} +(1-\beta_1)\cdot g_t \;(Update\; biased\; first\; moment\; estimate) $</p><p>$\qquad \qquad v_t \leftarrow \beta_2 \cdot v_{t-1} +(1-\beta_2)\cdot g_t^2 \;(Update\; biased\; second\; raw\; moment\; estimate) $</p><p>$\qquad \qquad \hat{m_t} \leftarrow m_t/(1-\beta_1^t) \;(Compute\; bias-corrected\; first\; moment\; estimate) $</p><p>$\qquad \qquad \hat{v_t} \leftarrow v_t/(.1-\beta_2^t) \;(Compute\; bias-corrected\; second\; raw \; moment\; estimate) $</p><p>$\qquad \qquad \theta_t \leftarrow \theta{t-1} - \alpha\cdot \hat{m_t}/(\sqrt{\hat v_t} +\epsilon ) \;(Update \; parameters)$</p><p>$\qquad \bf{end\; while}$</p><p>$\qquad \bf{return} \; \theta_t \;(Resulting \; parameters) $</p><hr><p>​    第二节介绍了算法及其更新规则的性质。第3节介绍了我们的初始化偏差校正技术，第4节对在线凸规划中的Adam收敛性进行了理论分析。从经验上讲，我们的方法在各种模型和数据集上始终优于其他方法，如第6节所示。总的来说，我们证明了Adam是一个多功能的算法，可以扩展到大规模的高维机器学习问题。</p><h2 id="第二部分：算法"><a href="#第二部分：算法" class="headerlink" title="第二部分：算法"></a>第二部分：算法</h2><p>​    我们提出的算法Adam的伪代码见算法1。设$f(\theta)$是一个有噪声的目标函数：一个可微$w.r.t.$参数$ \theta$的随机标量函数。我们感兴趣的是最小化这个函数的期望值，$\mathbb{E}[f(\theta)]\,w.r.t. $它的参数$\theta$。用$f_1(\theta), \cdots, f_T(\theta) $表示随机函数在随后的时间步骤$1，\cdots，T$的实现。随机性可能来自于对数据点的随机子样本（小批量）的评估，也可能来自固有的函数噪声。用$g_t=\bigtriangledown_{\theta}f_t(\theta)$表示梯度，即在时间步长t处计算的$f_t，w.r.t\;\theta$的偏导数向量。</p><p>​    该算法更新梯度$m_t$和平方梯度$v_t$的指数移动平均，其中超参数$β_1，β_2\in[0，1）$控制这些移动平均的指数衰减率。移动平均值本身就是梯度的第一个矩（平均值）和第二个原始矩（无中心方差）的估计值。然而，这些移动平均值被初始化为（向量）0，导致矩估计值偏向于零，特别是在初始时间步长期间，尤其是当衰减率很小（即$\beta_s$接近1）时。好消息是，这种初始化偏差可以很容易地抵消，从而得到偏差校正的估计值$\hat m_t$和$\hat v_t$。有关更多详细信息，请参阅第3节。</p><p>​    注意，算法1的效率可以通过改变计算顺序（例如，用下面的行替换循环中的最后三行）来提高算法1的效率:</p><script type="math/tex; mode=display">\alpha_t=\frac {\alpha \cdot \sqrt{1-\beta^t_2}}{(1-\beta^t_1)}</script><script type="math/tex; mode=display">\theta_t = \theta_{t-1}-\frac{\alpha_t\cdot m_t}{(\sqrt{v_t}+\hat \epsilon )}</script><h3 id="2-1-Adam更新率"><a href="#2-1-Adam更新率" class="headerlink" title="2.1 Adam更新率"></a>2.1 Adam更新率</h3><p>​    Adam更新规则的一个重要属性是它对步长的谨慎选择。假设$\epsilon =0$，时间步长t在参数空间中采取的有效步骤为$\Delta_t=\alpha\cdot \frac{\hat m_t}{\sqrt{\hat v_t}}. $</p><p>有效步长有两个上界：在$(1-\beta_1)&gt;\sqrt{1-\beta_2}$的情况下$\left|\Delta_{t}\right| \leq \alpha \cdot\left(1-\beta_{1}\right) / \sqrt{1-\beta_{2}}  $,以及$\left|\Delta_{t}\right| \leq \alpha$。否则,第一种情况只发生在最严重的稀疏情况下：梯度在除当前时间步以外的所有时间步上都为零。对于较少稀疏的情况，有效步长将更小。当$\left(1-\beta_{1}\right)=\sqrt{1-\beta_{2}}$情况下，有$\left|\hat{m}_{t} / \sqrt{\hat{v}_{t}}\right|&lt;1$因此$\left|\Delta_{t}\right|&lt;\alpha$。在更普通的场景中，因为$|\mathbb{E}[g] / \sqrt{\mathbb{E}\left[g^{2}\right]}| \leq 1$我们有$\widehat{m}_{t} / \sqrt{\widehat{v}_{t}} \approx \pm 1$ .每个时间步在参数空间中所采取的有效步长近似为步长设置α的范围，即$\left|\Delta_{t}\right| \leqq \alpha$。这可以理解为在当前参数值周围建立一个信任区域，超过该区域，当前梯度估计无法提供足够的信息。这通常使得提前知道α的正确刻度相对容易。例如，对于许多机器学习模型，我们通常预先知道好的最优解在参数空间的某个集合区域内具有高概率；例如，对参数具有先验分布的情况并不少见。由于α在参数空间中设置了步长（的上界），我们通常可以推导出α的正确量级，从而在一定的迭代次数内从$\theta_0$到达最优值。稍加滥用术语，我们将比率$\hat{m}_{t} / \sqrt{\widehat{v}_{t}}$称为信噪比$（SNR）$。信噪比越小，有效步长$∆t$将更接近于零。这是一个理想的特性，因为较小的信噪比意味着$\hat m_t$的方向是否与真实梯度的方向相对应存在更大的不确定性。例如，$SNR$值通常会向最优值靠拢，从而导致参数空间中的有效步长更小：这是自动退火的一种形式。有效步长$∆t$也与梯度的比例不变性；用系数c重新缩放梯度g将用系数c缩放$\hat{m}_{t}$，用系数$c^2$缩放$\hat{v}_{t}$这抵消了$\hat{m}_{t} / \sqrt{\widehat{v}_{t}}\left(c \cdot \hat{m}_{t}\right) /(\sqrt{c^{2} \cdot \hat{v}_{t}})=\hat{m}_{t} / \sqrt{\hat{v}_{t}}$。</p><h2 id="第三部分：初始化偏差校正"><a href="#第三部分：初始化偏差校正" class="headerlink" title="第三部分：初始化偏差校正"></a>第三部分：初始化偏差校正</h2><p>​    如第2节所述，Adam使用初始化偏差校正项。我们将在这里导出二阶矩估计的项；一阶矩估计的推导完全类似。设g是随机目标f的梯度，我们希望用平方梯度的指数移动平均估计其第二原始矩（无中心方差），衰减率为$β2$。设$g_1，\cdots，g_T$为后续时间步的梯度，每个都是从基本梯度分布$g_t∼p(gT)$中提取的。让我们将指数移动平均值初始化为$v_0=0$（零向量）。首先注意指数移动平均值$v_{t}=\beta_{2} \cdot v_{t-1}+\left(1-\beta_{2}\right) \cdot g_{t}^{2}$（其中$g_t^2$表明了元素平方$g_t\odot g_t$）在时间步长t处的更新可以写成所有先前时间步长的梯度函数：</p><script type="math/tex; mode=display">v_{t}=\left(1-\beta_{2}\right) \sum_{i=1}^{t} \beta_{2}^{t-i} \cdot g_{i}^{2} \tag{1}</script><p>​    我们想知道时间步长t处指数移动平均值的期望值$\mathbb{E}\left[v_{t}\right]$是如何与真实的第二时刻$\mathbb{E}\left[g_{t}^2\right]$相关的，因此我们可以纠正两者之间的差异。取等式（1）左右两侧的期望值：</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}\left[v_{t}\right] &=\mathbb{E}\left[\left(1-\beta_{2}\right) \sum_{i=1}^{t} \beta_{2}^{t-i} \cdot g_{i}^{2}\right] \\&=\mathbb{E}\left[g_{t}^{2}\right] \cdot\left(1-\beta_{2}\right) \sum_{i=1}^{t} \beta_{2}^{t-i}+\zeta \\&=\mathbb{E}\left[g_{t}^{2}\right] \cdot\left(1-\beta_{2}^{t}\right)+\zeta\end{aligned}</script><p>​    式中：$ζ=0$，如果真实第二力矩$\mathbb{E}\left[g_{i}^2\right]$是静止的；否则，$ζ$可以保持较小，因为指数衰减率$β1$可以（并且应该）被选择为指数移动平均为过去太远的梯度分配小权重。剩下的是项$（1−β_t)$，这是由用零初始化运行平均值引起的。因此，在算法1中，我们用这个项来修正初始化偏差。</p><p>​    在稀疏梯度的情况下，为了可靠地估计二阶矩，需要通过选择较小的$β2$值对许多梯度进行平均；然而，正是在小$β2$的情况下，缺少初始化偏差校正将导致初始步骤大得多。</p><h2 id="第四部分：收敛性分析"><a href="#第四部分：收敛性分析" class="headerlink" title="第四部分：收敛性分析"></a>第四部分：收敛性分析</h2><p>​    我们使用（Zinkevich，2003）提出的在线学习框架来分析Adam的收敛性。给定凸代价函数$f_1（θ），f_2（θ），\cdots，f_T（θ）$的任意未知序列。在每个时刻$t$，我们的目标是预测参数$θ_t$，并在先前未知的代价函数$f_t$上对其进行评估。由于序列的性质是预先未知的，因此我们使用遗憾来评估我们的算法，即在线预测$f_t(θt)$与来自前面所有步骤的可行集$\mathcal{X}$。具体地说，遗憾是指：</p><script type="math/tex; mode=display">R(T)=\sum_{t=1}^{T}\left[f_{t}\left(\theta_{t}\right)-f_{t}\left(\theta^{*}\right)\right] \tag{5}</script><p>​    其中$\theta^{*}=\arg \min _{\theta \in \mathcal{X}} \sum_{t=1}^{T} f_{t}(\theta)$。我们证明Adam没有遗憾边界，并在附录中给出了证明。我们的结果与一般凸在线学习问题的已知界相当。我们还使用一些定义来简化我们的符号，其中$g_{t} \triangleq \nabla f_{t}\left(\theta_{t}\right)$和$g_{t,i}$作为第i个元素。我们将$g_{1: t, i} \in \mathbb{R}^{t}$定义为一个向量，它包含所有迭代过程中梯度的第i维，直到t，$g_{1: t, i}=\left[g_{1, i}, g_{2, i}, \cdots, g_{t, i}\right]$。同样，我们定义$\gamma \triangleq \frac{\beta_{1}^{2}}{\sqrt{\beta_{2}}}$。当学习速率$α_t$以$t-1$的速率衰减时，我们的以下定理成立，并且第一时刻平均系数$β_{1,t}$以$λ$指数衰减，通常接近1，例如$1-10^{-8}$。</p><hr><p><strong>定理4.1</strong>. 假设函数ft具有有界梯度，$\left|\nabla f_{t}(\theta)\right|_{2} \leq G,\left|\nabla f_{t}(\theta)\right|_{\infty} \leqq G_{\infty}$对于所有的$\theta \in R^{d }$并且Adam生成的任何$θt$之间的距离是有界的，$\left|\theta_{n}-\theta_{m}\right|_{2} \leq D, \left|\theta_{m}-\theta_{n}\right|_{\infty} \leq D_{\infty}$对于任何$m, n \in\{1, \ldots, T\}, \text { and } \beta_{1}, \beta_{2} \in[0,1)$满足$\frac{\beta_{1}^{2}}{\sqrt{\beta_{2}}}&lt;1$，让$\alpha_{t}=\frac{\alpha}{\sqrt{t}}$并且$\beta_{1, t}=\beta_{1} \lambda^{t-1}, \lambda \in(0,1)$。Adam对于所有$T≥1$达到以下保证。</p><script type="math/tex; mode=display">R(T) \leq \frac{D^{2}}{2 \alpha\left(1-\beta_{1}\right)} \sum_{i=1}^{d} \sqrt{T \hat{v}_{T, i}}+\frac{\alpha\left(1+\beta_{1}\right) G_{\infty}}{\left(1-\beta_{1}\right) \sqrt{1-\beta_{2}}(1-\gamma)^{2}} \sum_{i=1}^{d}\left\|g_{1: T, i}\right\|_{2}+\sum_{i=1}^{d} \frac{D_{\infty}^{2} G_{\infty} \sqrt{1-\beta_{2}}}{2 \alpha\left(1-\beta_{1}\right)(1-\lambda)^{2}}</script><hr><p>我们的定理4.1表明，当数据特征是稀疏且有界梯度时，求和项可以远小于其上限$\sum_{i=1}^{d}\left|g_{1: T, i}\right|_{2}&lt;&lt;d G_{\infty} \sqrt{T}$并且$\sum_{i=1}^{d} \sqrt{T \widehat{v}_{T, i}}&lt;&lt;d G_{\infty} \sqrt{T}$,尤其是如果函数和数据特征的类别是第1.2节(Duchi等人，2011）的形式。他们对期望值$\mathbb{E}\left[\sum_{i=1}^{d}\left|g_{1: T, i}\right|_{2}\right]$的结果也适用于Adam。通常，类似于Adam与Adagrad的自适应方法，可以实现$O(\log d \sqrt{T})$相比于非自适应方法计算复杂度$O(\sqrt{d T})$的改进。在我们的理论分析中，将$β_{1,t}$衰减为零是很重要的，也与以前的经验结果相吻合，例如（Sutskever等人，2013年）表明在训练结束时降低动量系数可以提高收敛性。最后，我们可以展示Adam的平均遗憾.</p><hr><p><strong>推论4.2.</strong>假设函数$f_t$具有有界梯度，$\left|\nabla f_{t}(\theta)\right|_{2} \leq G,\left|\nabla f_{t}(\theta)\right|_{\infty} \leq G_{\infty} \text { for all } \theta \in R^{d}$并且Adam生成的任何$θt$之间的距离是有界的，$\left|\theta_{n}-\theta_{m}\right|_{2} \leq D,\left|\theta_{m}-\theta_{n}\right|_{\infty} \leq D_{\infty}$对任意的$m, n \in\{1, \ldots, T\}$。Adam达到以下保证，对于所有$T≥1$。</p><script type="math/tex; mode=display">\frac{R(T)}{T}=O\left(\frac{1}{\sqrt{T}}\right)</script><p>利用定理4.1和$\sum_{i=1}^{d}\left|g_{1: T, i}\right|_{2} \leq d G_{\infty} \sqrt{T}$可以得到这个结果。因此，$\lim _{T \rightarrow \infty} \frac{R(T)}{T}=0$。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Adam, 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下安装hexo并部署网站</title>
      <link href="/myblogs/2020/08/04/blog1-an-zhuang-hexo-yi-ji-wang-zhan-de-bu-shu/"/>
      <url>/myblogs/2020/08/04/blog1-an-zhuang-hexo-yi-ji-wang-zhan-de-bu-shu/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍在Windows操作系统上使用hexo生成个人博客的软件安装及环境配置，同时记录了过程中用到的相关命令。<br><a id="more"></a></p><h2 id="一、安装node-js"><a href="#一、安装node-js" class="headerlink" title="一、安装node.js"></a>一、安装node.js</h2><p>windows版本的官网链接为：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> ，<strong>安装过程中CustomSetup这一步记得检查Add—to-PATH是否被选上。</strong> 安装完成后命令行输入以下命令检查环境是否配好，正常情况下会返回软件版本号。</p><pre><code>npm -v</code></pre><h2 id="二、安装hexo"><a href="#二、安装hexo" class="headerlink" title="二、安装hexo"></a>二、安装hexo</h2><p>在Windows的cmd命令行中输入以下命令安装hexo并验证。</p><pre><code>npm install -g hexohexo -v</code></pre><p>如果出现以下错误：</p><pre><code>hexo : 无法加载文件 C:\Users\45478\AppData\Roaming\npm\hexo.ps1，因为在此系统上禁止运行脚本。</code></pre><p>可在管理员模式下的powershell中执行以下命令，输入y回车，之后问题解决。</p><pre><code>set-ExecutionPolicy RemoteSigned</code></pre><h2 id="三、生成博客"><a href="#三、生成博客" class="headerlink" title="三、生成博客"></a>三、生成博客</h2><p>步骤为创建工作目录，工作目录初始化，生成博客，开启本地服务预览网站。指令代码如下。</p><pre><code>hexo inithexo generate  hexo server</code></pre><h2 id="四、部署网站"><a href="#四、部署网站" class="headerlink" title="四、部署网站"></a>四、部署网站</h2><ul><li>首先执行以下命令安装hexo-deployer-git。</li></ul><pre><code>npm install hexo-deployer-git --save</code></pre><ul><li>网站的部署可以参考<a href="https://hexo.io/zh-cn/docs/one-command-deployment" target="_blank" rel="noopener">hexo</a>的官方教程，主要用到的命令如下。</li></ul><pre><code>hexo deploy</code></pre><ul><li>deploy之前需要更改_config.yml中deploy段的参数，可使用多个deployer。</li></ul><pre><code>deploy:- type: git  repo:- type: heroku  repo:</code></pre><ul><li>修改配置。</li></ul><pre><code>deploy:  type: git  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io  branch: [branch]  message: [message]</code></pre><ul><li>生成站点文件并推送至远程库。执行以下指令<pre><code>hexo clean hexo deploy</code></pre><h2 id="五、HEXO主题"><a href="#五、HEXO主题" class="headerlink" title="五、HEXO主题"></a>五、HEXO主题</h2>可以<a href="https://hexo.io/themes/" target="_blank" rel="noopener">在官网的主题页面</a>找适合自己的主题，本文所用的主题为<a href="https://volantis.js.org/" target="_blank" rel="noopener">volantis</a>，在此对主题的作者表示崇高的敬意！！!<br><img src="https://s1.ax1x.com/2020/08/05/arQSld.png" alt="volantis主题封面"></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> hexo, 部署网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/myblogs/2020/07/22/hello-world/"/>
      <url>/myblogs/2020/07/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
