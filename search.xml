<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python常用指令</title>
      <link href="/myblogs/2021/06/07/blog10-python-chang-yong-zhi-ling/"/>
      <url>/myblogs/2021/06/07/blog10-python-chang-yong-zhi-ling/</url>
      
        <content type="html"><![CDATA[<p>本文记录Python中常用的一些指令，方便以后调用查找。<br><a id="more"></a></p><h2 id="1、常用命令"><a href="#1、常用命令" class="headerlink" title="1、常用命令"></a>1、常用命令</h2><p>1、查看安装的所有包</p><pre class=" language-lang-python"><code class="language-lang-python">pip list</code></pre><p>2、安装删除包</p><pre class=" language-lang-python"><code class="language-lang-python">pip install cx-oraclepip uninstall cx-oracle</code></pre><p>3、导出包名字</p><pre class=" language-lang-python"><code class="language-lang-python">pip freeze > requirements.txt</code></pre><p>4、安装PyTorch</p><pre><code>pip3 install torch==1.8.1+cpu torchvision==0.9.1+cpu torchaudio===0.8.1 -f https://download.pytorch.org/whl/torch_stable.html</code></pre><p>5、通过requirements.txt安装依赖包</p><pre><code>pip install -r requirements.txt</code></pre><h2 id="2、虚拟环境"><a href="#2、虚拟环境" class="headerlink" title="2、虚拟环境"></a>2、虚拟环境</h2><h3 id="1、虚拟环境的安装"><a href="#1、虚拟环境的安装" class="headerlink" title="1、虚拟环境的安装"></a>1、虚拟环境的安装</h3><pre><code>pip install virtualenvvirtualenv   --测试</code></pre><h3 id="2、创建虚拟环境"><a href="#2、创建虚拟环境" class="headerlink" title="2、创建虚拟环境"></a>2、创建虚拟环境</h3><pre><code>virtualenv venv</code></pre><h3 id="3、激活退出虚拟环境"><a href="#3、激活退出虚拟环境" class="headerlink" title="3、激活退出虚拟环境"></a>3、激活退出虚拟环境</h3><pre><code>venv\Scripts\activate ---找到此位置并执行deactivate  ---执行此命令</code></pre><h3 id="4、扩展"><a href="#4、扩展" class="headerlink" title="4、扩展"></a>4、扩展</h3><p>virtualenvwrapper模块，可以管理全部的虚拟环境，更加方便地创建，删除，拷贝虚拟环境。</p><p>安装：</p><pre><code>pip install virtualenvwrapper</code></pre><p>准备：</p><p>需要在环境变量中添加一个环境变量，名字为WORKON_HOME,对应路径为虚拟环境的路径。</p><p>可用命令：</p><pre><code>mkvirtualenv ：创建虚拟环境lsvirtualenv：列出全部的虚拟环境showvirtualenv：列出单个虚拟机环境的信息rmvirtualenv：删除一个虚拟环境cpvirtualenv：拷贝一个虚拟环境allvirtualenv：对当前虚拟环境执行统一的命令cdvirtualenv：可以直接切换到虚拟环境的子目录里cdsitepackages：和cdvirtualenv同理，切换到虚拟环境的site-packages目录下lssitepackages：列出site-packages目录下的目录</code></pre><p>列出所有虚拟环境：</p><pre><code>workon</code></pre><h2 id="3、conda常用指令"><a href="#3、conda常用指令" class="headerlink" title="3、conda常用指令"></a>3、conda常用指令</h2><h3 id="1、常用命令-1"><a href="#1、常用命令-1" class="headerlink" title="1、常用命令"></a>1、常用命令</h3><pre><code>conda list 查看安装了哪些包。conda env list 或 conda info -e 查看当前存在哪些虚拟环境conda update conda 检查更新当前conda</code></pre><h3 id="2、创建虚拟环境-1"><a href="#2、创建虚拟环境-1" class="headerlink" title="2、创建虚拟环境"></a>2、创建虚拟环境</h3><pre class=" language-lang-python"><code class="language-lang-python">conda create -n xxx python=3.6</code></pre><h3 id="3、使用激活的虚拟环境"><a href="#3、使用激活的虚拟环境" class="headerlink" title="3、使用激活的虚拟环境"></a>3、使用激活的虚拟环境</h3><pre><code>python --version  # 可以检查当前python的版本Linux:  source activate your_env_name(虚拟环境名称)Windows: activate your_env_name(虚拟环境名称)</code></pre><h3 id="4、虚拟环境中安装额外的包"><a href="#4、虚拟环境中安装额外的包" class="headerlink" title="4、虚拟环境中安装额外的包"></a>4、虚拟环境中安装额外的包</h3><pre><code>conda install -n your_env_name [package]</code></pre><h3 id="5、关闭虚拟环境"><a href="#5、关闭虚拟环境" class="headerlink" title="5、关闭虚拟环境"></a>5、关闭虚拟环境</h3><pre><code>Linux: source deactivateWindows: deactivate</code></pre><h3 id="6、删除虚拟环境"><a href="#6、删除虚拟环境" class="headerlink" title="6、删除虚拟环境"></a>6、删除虚拟环境</h3><pre><code>conda remove -n your_env_name(虚拟环境名称) --allconda remove --name your_env_name  package_name  # 删除环境中的某个包</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Python, 虚拟环境, 指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab绘图常用指令</title>
      <link href="/myblogs/2021/06/07/blog9-matlab-hui-tu-chang-yong-zhi-ling/"/>
      <url>/myblogs/2021/06/07/blog9-matlab-hui-tu-chang-yong-zhi-ling/</url>
      
        <content type="html"><![CDATA[<p>本文记录Matlab绘图中常用的一些指令，方便以后调用查找。<br><a id="more"></a></p><h3 id="一、设置绘图窗口相关属性"><a href="#一、设置绘图窗口相关属性" class="headerlink" title="一、设置绘图窗口相关属性"></a>一、设置绘图窗口相关属性</h3><pre class=" language-lang-matlab"><code class="language-lang-matlab">set(gcf,'Position',[100 100 1400 450]);set(gca, 'YLim',[0.25 0.7]);set(gca, 'XLim',[0 0.6]);set(gca, 'XLim',[0 60]);set(gca, 'YLim',[-10 20]);set(gca, 'YTick', 0.25 :0.1:0.7);grid on;set(gca,'fontsize',15,'fontweight','normal','FontName','Times New Roman');</code></pre><h3 id="二、绘图"><a href="#二、绘图" class="headerlink" title="二、绘图"></a>二、绘图</h3><pre class=" language-lang-matlab"><code class="language-lang-matlab">figure(1)subplot(121)plot(x, y,'-*','linewidth',1.5,'color',color{1,i})xlabel({'Position-x (m)','(a)'});ylabel('Position-y (m)');hold on;axis equal;</code></pre><h3 id="三、设置legend"><a href="#三、设置legend" class="headerlink" title="三、设置legend"></a>三、设置legend</h3><pre class=" language-lang-matlab"><code class="language-lang-matlab">h=legend('iter1','iter2','iter3','iter4','iter5','desired');set(h, 'location', 'southwest', 'fontsize',15,'fontweight','normal','FontName','Times New Roman');set(h,'Orientation','horizon')</code></pre><h3 id="四、保存绘图"><a href="#四、保存绘图" class="headerlink" title="四、保存绘图"></a>四、保存绘图</h3><pre class=" language-lang-matlab"><code class="language-lang-matlab">saveas(gcf,'./figure/position-compare.eps','epsc')</code></pre><h3 id="五、绘制误差图"><a href="#五、绘制误差图" class="headerlink" title="五、绘制误差图"></a>五、绘制误差图</h3><pre class=" language-lang-matlab"><code class="language-lang-matlab">figure('name','error_bar');errorbar(iter_num, data_mean(1,:,1), data_error(1,:,1),'-r.','LineWidth',2,'MarkerSize',25);set(h,'fontsize',15,'fontweight','normal','FontName','Times New Roman')xlabel({'Iteration number (t)','(a)'});ylabel('Average position error (m)');set(gca,'fontsize',15,'fontweight','normal','FontName','Times New Roman'); set(gca, 'XTick', 0:1:5)</code></pre><h3 id="六、添加latex字符"><a href="#六、添加latex字符" class="headerlink" title="六、添加latex字符"></a>六、添加latex字符</h3><pre class=" language-lang-matlab"><code class="language-lang-matlab">text(0.6, 0.5, '\leftarrow\alpha_2^\beta');text('Interpreter', 'latex', 'String', '$$\int_0^x\! \int_y dF(u, v)$$', ...     'Position', [3 0.5], 'FontSize', 16)ax1 = subplot(2,1,1,'FontSize',14);xticks(0:0.2:1);xticklabels({'0','1\B','2\B','3\B','4\B','5\B'});ax2 = subplot(2,1,2,'FontSize',14);xticks(0:0.2:1);xticklabels({'${0}$','$\frac{1}{B}$','$\frac{2}{B}$',...    '$\frac{3}{B}$','$\frac{4}{B}$','$\frac{5}{B}$'});ax2.TickLabelInterpreter = 'latex';h=legend('$$\sqrt{x^2+y^2}$$');set(h,'Interpreter','latex');xlabel('$$\sqrt{x}$$','Interpreter', 'latex');</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Matlab, 绘图, 指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webots盾构仿真基本操作</title>
      <link href="/myblogs/2021/03/18/blog8-webots-dun-gou-fang-zhen-ji-ben-cao-zuo/"/>
      <url>/myblogs/2021/03/18/blog8-webots-dun-gou-fang-zhen-ji-ben-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了一下webots中盾构仿真的工程目录结构及基本操作。<br><a id="more"></a></p><h2 id="一、文件目录结构"><a href="#一、文件目录结构" class="headerlink" title="一、文件目录结构"></a>一、文件目录结构</h2><p>盾构仿真工程中的相关文件目录如下：</p><p><a href="https://imgtu.com/i/62GnsK" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/03/18/62GnsK.md.png" alt="62GnsK.md.png"></a></p><p>其中，</p><ol><li>Controllers里面存放了各个机构对应的控制器程序。</li><li>docs存放了该工程中记录的一些文档以及参考的一些资料。</li><li>protos文件夹存放了protos文件（通过机器人的urdf文件导出生成）。</li><li>wbo文件夹存放从webots里面导出的节点文件，如管片节点，轴线显示点的节点等等。</li><li>webots_world为webots仿真场景文件，里面包含所有的机器人，环境等实际对象。</li><li>wrl里面存放了从3D建模软件中导出的一些3D模型文件，其文件类型有stl，wrl等;</li></ol><h2 id="二、Webots环境简介"><a href="#二、Webots环境简介" class="headerlink" title="二、Webots环境简介"></a>二、Webots环境简介</h2><p>Webots是一个基于ODE（开源物理引擎）所开发的一款开源机器人仿真环境，通过此软件，可以实现自主设计机器人的虚拟仿真，验证算法等，其能够较为真实的模拟真实世界的重力，摩擦力，光线，流体等物理对象，同时也提供了非常多的演示例子，包括针对于每个传感器，每种接口的基础例子，以及针对自动驾驶等大型城市，村庄场景演示。除此之外，此平台提供了非常便利的编程语言接口，可以通过控制器程序实现对机器人本身的基础控制，也可通过主管控制器接口来在程序中对场景中任意节点的任意属性执行更改，除此之外，用户还可以通过编写物理插件来实现更符合自己需求的功能。</p><h3 id="2-1、盾构仿真场景主界面"><a href="#2-1、盾构仿真场景主界面" class="headerlink" title="2.1、盾构仿真场景主界面"></a>2.1、盾构仿真场景主界面</h3><p><a href="https://imgtu.com/i/62G3id" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/03/18/62G3id.png" alt="62G3id.png"></a><br>可以在3D视图窗口点击鼠标右键，选择添加节点，像场景添加可视对象或相关属性节点。</p><h3 id="2-2、盾构仿真需要用到基本程序接口"><a href="#2-2、盾构仿真需要用到基本程序接口" class="headerlink" title="2.2、盾构仿真需要用到基本程序接口"></a>2.2、盾构仿真需要用到基本程序接口</h3><ol><li>直线电机旋转电机（油缸、刀盘驱动）的位置，速度，力矩控制等。</li><li>主管控制器接口动态的向场景添加管片，标签，或是虚拟的标识线，标示物体等。</li><li>使用matlab仿真过程可以在控制器的头部添加如下代码，实现代码的调试。</li></ol><pre class=" language-lang-matlab"><code class="language-lang-matlab">desktop;keyboard;</code></pre><h3 id="2-3、盾构控制器程序设计"><a href="#2-3、盾构控制器程序设计" class="headerlink" title="2.3、盾构控制器程序设计"></a>2.3、盾构控制器程序设计</h3><p>stm_controller ：实现主函数，完成沿轴线自主推进。</p><p>|———CylinderController: 此类为油缸分组控制器类，可以通过此类实现油缸的分组控制。</p><p>|———SupervisorController:主控控制器类，在此类中实现对场景的基本操作，如向其中添加节点，设置节点的属性（更改节点的位置等）等。</p><p>|———DTADesign: 隧道期望中心轴线类，在此类中可实现纠偏路径、期望轴线的设计、期望轴线的可视化显示等等功能。</p><p><a href="https://imgtu.com/i/62GMZD" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/03/18/62GMZD.png" alt="62GMZD.png"></a><br><a href="https://imgtu.com/i/62GlIH" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/03/18/62GlIH.png" alt="62GlIH.png"></a><br><a href="https://imgtu.com/i/62G3id" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/03/18/62G3id.png" alt="62G3id.png"></a><br>后面可逐步扩展类，及类里面的成员函数。</p><h3 id="2-4、运行此世界可能遇到的问题"><a href="#2-4、运行此世界可能遇到的问题" class="headerlink" title="2.4、运行此世界可能遇到的问题"></a>2.4、运行此世界可能遇到的问题</h3><ol><li>某些节点调用的资源文件在更换电脑后其路径会发生改变，要注意命令行窗口的报错信息，更改对应资源文件的路径设置。</li><li>Matlab缺少相应的软件功能包，可在matlab附加功能里面搜索对应的软件包名称，登录账号安装即可。</li></ol><h3 id="2-5、下一步仿真路线"><a href="#2-5、下一步仿真路线" class="headerlink" title="2.5、下一步仿真路线"></a>2.5、下一步仿真路线</h3><ol><li>设计期望的推进轴线。</li><li>控制每组油缸推进长度，刀盘的旋转速度，实现对盾构位姿的控制。</li><li>在前两步基础上，让盾构延期望轴线精确推进。</li><li>更新环境模拟机构，使其能更为合理的模拟土体作用。</li><li>在对应的机构上部署推导出的数学模型以及控制率，实现更接近真实的仿真。</li><li>可视化显示推进参数等。</li></ol><h3 id="2-6、小技巧"><a href="#2-6、小技巧" class="headerlink" title="2.6、小技巧"></a>2.6、小技巧</h3><ol><li>需要向场景添加模型文件，可以从solidworks导出vrml97类型文件，然后导入到webots中，注意设置webots里面边界对象，否则检测不到碰撞，会出现穿模的情况。</li><li>可视化轴线可以采用主管控制器接口，向其中添加多个轴线点节点来实现，也可以参考supervisor_draw_trail.wbt例程，可视化轴线。</li><li>可视化接触力大小可借鉴技巧2中的实现方法。</li></ol><h2 id="三、Webots参考文档"><a href="#三、Webots参考文档" class="headerlink" title="三、Webots参考文档"></a>三、Webots参考文档</h2><p>用户指南：<a href="https://cyberbotics.com/doc/guide/index" target="_blank" rel="noopener">https://cyberbotics.com/doc/guide/index</a><br>参考手册：<a href="https://cyberbotics.com/doc/reference/index" target="_blank" rel="noopener">https://cyberbotics.com/doc/reference/index</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 盾构，webots </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单液压缸仿真</title>
      <link href="/myblogs/2020/11/06/blog7-dan-ye-ya-gang-fang-zhen/"/>
      <url>/myblogs/2020/11/06/blog7-dan-ye-ya-gang-fang-zhen/</url>
      
        <content type="html"><![CDATA[<p>本文参考网址：<a href="https://www.mathworks.com/help/simulink/slref/single-hydraulic-cylinder-simulation.html" target="_blank" rel="noopener">https://www.mathworks.com/help/simulink/slref/single-hydraulic-cylinder-simulation.html</a><br><a id="more"></a></p><h2 id="一、模型的分析与物理描述"><a href="#一、模型的分析与物理描述" class="headerlink" title="一、模型的分析与物理描述"></a>一、模型的分析与物理描述</h2><p>图1展示了该系统的原理结构，此模型中油泵流量$Q$在控制阀处提供压力$p_1$，$C_2$为溢流阀，其流量被定义为$q_{1ex}$，活塞/缸体组件的控制阀建模为对可变直径管道的液体流的控制，液体流$q_{12}$，引起了液体压力$p_2$，它在将其连接到执行器气缸的管路中承受随后的压降。液缸压力$p_3$，推动弹性负载的移动并产生位移量$x$。</p><p><a href="https://imgchr.com/i/BWeRW4" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/05/BWeRW4.png" alt="BWeRW4.png"></a></p><p>在泵的输出端，流量被分流到溢流阀和控制阀两部分，我们将溢出流量$q_{1ex}$建模为层流，如下：</p><script type="math/tex; mode=display">\begin{array}{l}Q=q_{12}+q_{1 e x} \\q_{1 e x}=C_{2} \cdot p_{1} \\p_{1}=\frac{\left(Q-q_{12}\right)}{C_{2}} \\Q=\text { pump flow } \\q_{12}=\text { control valve flow } \\q_{1 e x}=\text { leakage } \\C_{2}=\text { flow coefficient } \\p_{1}=\text { pump pressure }\end{array}</script><p>我们用节流孔方程对通过控制阀的液流进行了建模。符号和绝对值函数可适应任一方向的流量，如下：</p><script type="math/tex; mode=display">\begin{array}{l}q_{12}=C_{d} \cdot A \cdot \operatorname{sgn}\left(p_{1}-p_{2}\right) \cdot \sqrt{\frac{2}{\rho}\left|p_{1}-p_{2}\right|} \\C_{d}=\text { orifice discharge coefficient，孔流系数。 } \\A=\text { orifice area 孔面积。} \\p_{2}=\text { pressure downstream of control valve，控制阀下游的压力。 } \\\rho=\text { fluid density }\end{array}</script><p>气缸内的流体由于该流量而增压，$q_{12} = q_{23}$，减去活塞运动的顺应性。在这种情况下，我们还对流体的可压缩性进行了建模。</p><script type="math/tex; mode=display">\begin{array}{l}\frac{d p_{3}}{d t}=\frac{\beta}{V_{3}}\left(q_{12}-A_{c} \frac{d x}{d t}\right) \\V_{3}=V_{30}+A_{c} \cdot x \\p_{3}=\text { piston pressure } \\\beta=\text { fluid bulk modulus, 液体弹性模量。} \\V_{3}=\text { fluid volume at } p_{3} \\V_{30}=\text { fluid volume in the piston for } x=0 \\A_{c}=\text { cylinder cross-sectional area，液缸截面积。}\end{array}</script><p>由于较大的液压力，我们忽略了活塞和弹簧的质量。我们通过微分这种关系并结合p2和p3之间的压降来完成方程组。 Equation Block 3对从阀到执行器的管路中的层流进行建模。下列方程给出了活塞处的力平衡。</p><script type="math/tex; mode=display">\begin{array}{l}x=p_{3} \frac{A_{c}}{K} \\\frac{d x}{d t}=\frac{d p_{3}}{d t} \frac{A_{c}}{K} \\q_{23}=q_{12}=C_{1}\left(p_{2}-p_{3}\right) \\p_{2}=p_{3}+\frac{q_{12}}{C_{1}} \\K=\text { spring constant } \\C_{1}=\text { laminar flow coefficient }\end{array}</script><h2 id="二、泵子系统"><a href="#二、泵子系统" class="headerlink" title="二、泵子系统"></a>二、泵子系统</h2><p>右键单击$Pump Masked$子系统，然后选择 <strong>Mask</strong> &gt; <strong>Look Under Mask</strong>。泵模型根据泵流量和负载（输出）流量计算供应压力（下图）。 $Qpump$是泵流量数据（保存在模型工作区中）。具有时间点列向量和相应流量$[T，Q]$的矩阵指定流量数据。该模型按公式块1所示计算压力$p_1$。由于$Qout = q_{12}$是$p1$的直接函数（通过控制阀），因此形成了代数环路。估计初始值$p10$可以实现更有效的解决方案。</p><p><a href="https://imgchr.com/i/BW14Zd" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/05/BW14Zd.png" alt="BW14Zd.png"></a></p><h2 id="三、阀门、油缸、活塞，弹簧等组成的子系统"><a href="#三、阀门、油缸、活塞，弹簧等组成的子系统" class="headerlink" title="三、阀门、油缸、活塞，弹簧等组成的子系统"></a>三、阀门、油缸、活塞，弹簧等组成的子系统</h2><p>微分代数方程组用压力$p_3$来模拟气缸增压，压力在方程式3中作为导数出现，并用作状态（积分器）。如果忽略活塞质量，则弹簧力和活塞位置是$p_3$的直接倍数，而速度是$p_3$的时间导数的直接倍数。后一种关系在$“ Beta”$增益块周围形成代数循环。中间压力$p_2$是$p_3$与由于从阀流向气缸的流量而引起的压降之和（公式框4）。这种关系还通过控制阀和$1/C_1$增益施加了代数约束。</p><p><a href="https://imgchr.com/i/BfoNn0" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfoNn0.png" alt="BfoNn0.png"></a></p><h2 id="四、仿真结果"><a href="#四、仿真结果" class="headerlink" title="四、仿真结果"></a>四、仿真结果</h2><p>仿真数据参数设置如下：该信息是从$MAT$文件$sldemo_hydcyl_data.mat$加载的，该文件也用于其他两个液压缸模型。用户可以通过泵和气缸$Mask$输入数据。</p><script type="math/tex; mode=display">\begin{array}{l}C_{d}=0.61 \\\rho=800 \mathrm{kg} / \mathrm{m}^{3} \\C_{1}=2 e-8 \mathrm{m}^{3} / \mathrm{sec} / \mathrm{Pa} \\C_{2}=3 e-9 \mathrm{m}^{3} / \mathrm{sec} / \mathrm{Pa} \\\beta=7 e 8 \mathrm{Pa} \\A_{c}=1 e-3 \mathrm{m}^{2} \\K=5 e 4 \mathrm{N} / \mathrm{m} \\V_{30}=2.5 e-5 \mathrm{m}^{3}\\\begin{array}{l}T=\left[\begin{array}{llllll}0 & 0.04 & 0.04 & 0.05 & 0.05 & 0.1\end{array}\right] \text { sec } \\Q=\left[\begin{array}{lllll}0.005 & 0.005 & 0 & 0 & 0.005 & 0.005\end{array}\right] \mathrm{m}^{\wedge} 3 / \mathrm{sec}\end{array}\end{array}</script><h3 id="仿真结果图："><a href="#仿真结果图：" class="headerlink" title="仿真结果图："></a>仿真结果图：</h3><p>系统最初逐步达到$0.005\; \mathrm{m}^{\wedge} 3 / \mathrm{sec}=300 \;\mathrm{l} / \mathrm{min}$的泵流量,在$t=0.04s$时流速突然下降到$0$，然后在$t = 0.05$秒时恢复其初始流速。</p><p>控制阀在$0.1s$的仿真时间内，从$0$初始面积逐步增到$1e-4 \; sq.m$。随着阀门的关闭，所有的流量都从溢流阀泄露，初始的泵压力增加到$p_{10}=Q/C_2=1667kPa$。</p><p>如图7所示，当阀打开时，压力$p_2$和$p_3$增大，而$p_1$则根据负载的增加而减小，当泵流量切断时，弹簧和活塞就像一个蓄能器，而$p_3$则连续减小。然后，流体反向流动，因此尽管$p_2$相对接近$p_3$，却突然下降。在泵本身，所有的回流泄漏和$p_1$都急剧下降。还原续流后，行为会相反。</p><p><a href="https://imgchr.com/i/BfLfEt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfLfEt.png" alt="BfLfEt.png"></a></p><p><a href="https://imgchr.com/i/BfLIC8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/06/BfLIC8.png" alt="BfLIC8.png"></a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 液压缸，matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用粒子过滤器跟踪类车机器人</title>
      <link href="/myblogs/2020/11/06/blog6-shi-yong-li-zi-guo-lu-qi-gen-zong-lei-che-ji-qi-ren/"/>
      <url>/myblogs/2020/11/06/blog6-shi-yong-li-zi-guo-lu-qi-gen-zong-lei-che-ji-qi-ren/</url>
      
        <content type="html"><![CDATA[<p>本例参考网址：<a href="https://ww2.mathworks.cn/help/robotics/ug/track-a-car-like-robot-using-particle-filter.html" target="_blank" rel="noopener">https://ww2.mathworks.cn/help/robotics/ug/track-a-car-like-robot-using-particle-filter.html</a><br><a id="more"></a><br>粒子滤波器是一种基于采样的递归贝叶斯估计算法，该算法在stateEstimatorPF对象中实现。在本例中，户外环境下一个类车机器人将被跟踪，机器人位置的测量通过板载的带有噪声的GPS来实现。将已知的运动命令发送给机器人，由于固有的延迟以及模型的不准确性，机器人并不会执行确切的运动指令。本文示例将说明如何使用stateEstimatorPF对象来减少测量数据中的噪声影响，并获得对机器人位置的更准确的估计。汽车类机器人的运动学模型由以下非线性系统描述。粒子滤波器非常适合估计此类系统的状态，因为它可以处理固有的非线性。</p><script type="math/tex; mode=display">\dot{x}=vcos(\theta)\\\dot{y}=vsin(\theta)\\\dot{\theta}=\frac{v}{L}tan\phi\\\dot{\phi}=\omega</script><h2 id="一、场景描述"><a href="#一、场景描述" class="headerlink" title="一、场景描述"></a>一、场景描述</h2><p>类似于汽车的机器人不断驱动并改变其速度和转向角。机器人的位置的测量是由一些嘈杂的外部系统（例如GPS或Vicon系统）来实现的。沿着这条路径，它将穿过无法进行测量的室内区域。</p><p><a href="https://imgchr.com/i/Bdqca6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/01/Bdqca6.png" alt="Bdqca6.png"></a></p><p><strong>输入：</strong></p><ul><li>机器人局部位置的噪声测量值$(x,y,\theta)$。注意这不是全状态的测量，前轮的方向$\phi$以及$(\dot{x},\dot{y},\dot{\theta},\dot{\phi})$是没有测量的。</li><li>线速度及角速度指令$v_{C^{‘}},\omega_C$被发送给机器人。注意机器人的指令运动与实际运动之间会有一些差异。</li></ul><p><strong>目标：</strong>估计类车机器人的局部位置$(x,y,\theta)$。注意车轮方向不包含在估计中，从观测器的角度看，车的全状态为$[x,y,\theta,\dot{x},\dot{y},\dot{\theta}]$</p><p>。</p><p><strong>方法：</strong>使用<a href="https://ww2.mathworks.cn/help/robotics/ref/stateestimatorpf.html" target="_blank" rel="noopener"><code>stateEstimatorPF</code></a>函数处理两个带有噪声的输入（两个输入本身都不可靠），并对当前部分位置进行最优估计。</p><ul><li>在预测阶段，我们使用简化的，类似于独轮车的机器人模型更新粒子的状态，如下所示。请注意，用于状态估计的系统模型不是实际系统的精确表示。只要可以很好地捕获系统噪声（以粒子群表示）中的模型差异，这是可以接受的。有关更多详细信息，请参见 <a href="https://ww2.mathworks.cn/help/robotics/ref/stateestimatorpf.predict.html" target="_blank" rel="noopener"><code>predict</code></a>。</li></ul><script type="math/tex; mode=display">\dot{x}=vcos(\theta)\\\dot{y}=vsin(\theta)\\\dot{\theta}=\omega</script><ul><li>在修正阶段，粒子的重要权值（似然性）由当前测量的误差范数确定$(\sqrt{(\Delta x)^2+(\Delta y)^2+(\Delta \theta)^2})$，因为我们仅对这三个变量进行测量，更多详细信息参见 <a href="https://ww2.mathworks.cn/help/robotics/ref/stateestimatorpf.correct.html" target="_blank" rel="noopener"><code>correct</code></a>.</li></ul><h2 id="二、初始化类车机器人"><a href="#二、初始化类车机器人" class="headerlink" title="二、初始化类车机器人"></a>二、初始化类车机器人</h2><pre class=" language-lang-matlab"><code class="language-lang-matlab">rng('default'); % for repeatable resultdt = 0.05; % time stepinitialPose = [0  0  0  0]';carbot = ExampleHelperCarBot(initialPose, dt);</code></pre><p><a href="https://imgchr.com/i/BdxXWV" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/01/BdxXWV.png" alt="BdxXWV.png"></a></p><h2 id="三、设置粒子滤波器"><a href="#三、设置粒子滤波器" class="headerlink" title="三、设置粒子滤波器"></a>三、设置粒子滤波器</h2><p>本部分使用5000个粒子配置粒子过滤器。最初，所有粒子都是从正态分布中随机选取的，其初始状态和单位协方差为均值。每个粒子包含6个状态变量$(x,y,\theta,\dot{x},\dot{y},\dot{\theta})$。注意，第三个变量标记为圆形，因为它是汽车的方向。指定两个回调函数$StateTransitionFcn$和$MeasurementLikelihoodFcn$也非常重要。这两个函数直接决定了粒子过滤器的性能。这两个函数的详细信息可以在本示例的最后两个部分中找到。</p><pre class=" language-lang-matlab"><code class="language-lang-matlab">pf = stateEstimatorPF;initialize(pf, 5000, [initialPose(1:3)', 0, 0, 0], eye(6), 'CircularVariables',[0 0 1 0 0 0]);pf.StateEstimationMethod = 'mean';pf.ResamplingMethod = 'systematic';% StateTransitionFcn defines how particles evolve without measurementpf.StateTransitionFcn = @exampleHelperCarBotStateTransition;% MeasurementLikelihoodFcn defines how measurement affect the our estimationpf.MeasurementLikelihoodFcn = @exampleHelperCarBotMeasurementLikelihood;% Last best estimation for x, y and thetalastBestGuess = [0 0 0];</code></pre><h2 id="四、主循环"><a href="#四、主循环" class="headerlink" title="四、主循环"></a>四、主循环</h2><p>注意，在此示例中，命令给机器人的线性和角速度是随时间变化的任意函数。另外，注意循环的固定速率计时是通过 <a href="https://ww2.mathworks.cn/help/robotics/ref/ratecontrol.html" target="_blank" rel="noopener"><code>rateControl</code></a>实现的。</p><p>使用固定速率支持以20 Hz的频率运行20秒。</p><pre class=" language-lang-matlab"><code class="language-lang-matlab">r = rateControl(1/dt);</code></pre><p>重置固定速率对象以重新启动计时器。在运行与时间有关的代码之前，请立即重置计时器。</p><pre class=" language-lang-matlab"><code class="language-lang-matlab">reset(r);simulationTime = 0; while simulationTime < 20 % if time is not up    % Generate motion command that is to be sent to the robot    % NOTE there will be some discrepancy between the commanded motion and the    % motion actually executed by the robot.     uCmd(1) = 0.7*abs(sin(simulationTime)) + 0.1;  % linear velocity    uCmd(2) = 0.08*cos(simulationTime);            % angular velocity    drive(carbot, uCmd);    % Predict the carbot pose based on the motion model    [statePred, covPred] = predict(pf, dt, uCmd);    % Get GPS reading    measurement = exampleHelperCarBotGetGPSReading(carbot);    % If measurement is available, then call correct, otherwise just use    % predicted result    if ~isempty(measurement)        [stateCorrected, covCorrected] = correct(pf, measurement');    else        stateCorrected = statePred;        covCorrected = covPred;    end    lastBestGuess = stateCorrected(1:3);    % Update plot    if ~isempty(get(groot,'CurrentFigure')) % if figure is not prematurely killed        updatePlot(carbot, pf, lastBestGuess, simulationTime);    else        break    end    waitfor(r);    % Update simulation time    simulationTime = simulationTime + dt;end</code></pre><p><a href="https://imgchr.com/i/BdzW79" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/01/BdzW79.png" alt="BdzW79.png"></a></p><h2 id="五、结果图说明"><a href="#五、结果图说明" class="headerlink" title="五、结果图说明"></a>五、结果图说明</h2><p>这三个图显示了粒子滤波器的跟踪性能。</p><ul><li>在第一个图中，粒子过滤器在偏离初始姿势的情况下很好地跟踪了汽车。</li><li>在第二幅图中，机器人驶入无法进行测量的屋顶区域，并且粒子仅基于预测模型（标有橙色）而演化。您可以看到粒子逐渐形成马蹄形的前部，并且估计的姿势逐渐偏离实际的姿势。</li><li>在第三张图中，机器人已驶出屋顶区域。通过新的测量，估计的姿势逐渐收敛到实际姿势。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 机器人，matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS2常用指令</title>
      <link href="/myblogs/2020/10/25/blog5-ros2-chang-yong-zhi-ling/"/>
      <url>/myblogs/2020/10/25/blog5-ros2-chang-yong-zhi-ling/</url>
      
        <content type="html"><![CDATA[<p>本文记录ROS2常用的命令行操作指令。包括话题，服务，参数，动作等命令行命令。本文参考博客链接为：<a href="https://www.guyuehome.com/category/column/ros2-tutorials。" target="_blank" rel="noopener">https://www.guyuehome.com/category/column/ros2-tutorials。</a><br><a id="more"></a></p><h2 id="一、安装调试过程"><a href="#一、安装调试过程" class="headerlink" title="一、安装调试过程"></a>一、安装调试过程</h2><ul><li>将指令写入环境变量：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    echo "source /opt/ros/foxy/setup.bash" >> ~/.bashrc</code></pre><ul><li>查看环境变量是否写入成功：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    printenv | grep -i ROS</code></pre><ul><li>设置ROS组网ID:</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    export ROS_DOMAIN_ID=<your_domain_id>    echo "export ROS_DOMAIN_ID=<your_domain_id>" >> ~/.bashrc</code></pre><ul><li>安装海龟仿真器：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    sudo apt update    sudo apt install ros-foxy-turtlesim</code></pre><ul><li>检查功能包是否安装成功：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 pkg executables turtlesim</code></pre><ul><li>启动海龟仿真器节点：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 run turtlesim turtlesim_node</code></pre><ul><li>查看节点，话题，服务，动作：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 node list    ros2 topic list    ros2 service list    ros2 action list</code></pre><ul><li>安装rqt工具：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    sudo apt update    sudo apt install ~nros-foxy-rqt*</code></pre><ul><li>通过remapping 给节点重命名：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 run turtlesim turtle_teleop_key --ros-args --remap turtle1/cmd_vel:=turtle2/cmd_vel</code></pre><h2 id="二、节点相关指令"><a href="#二、节点相关指令" class="headerlink" title="二、节点相关指令"></a>二、节点相关指令</h2><ul><li>启动节点程序：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 run <package_name> <executable_name>    ros2 run turtlesim turtlesim_node</code></pre><ul><li>列出节点：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 node list</code></pre><ul><li>重映射：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle</code></pre><ul><li>查看节点信息：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 node info <node_name>    ros2 node info /my_turtle</code></pre><h2 id="三、话题相关指令"><a href="#三、话题相关指令" class="headerlink" title="三、话题相关指令"></a>三、话题相关指令</h2><ul><li>列出所有话题：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 topic list    ros2 topic list -t    #显示消息数据类型</code></pre><ul><li>返回话题数据：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 topic echo <topic_name>    ros2 topic echo /turtle1/cmd_vel</code></pre><ul><li>显示话题信息：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 topic info /turtle1/cmd_vel</code></pre><ul><li>查看话题中消息的具体数据结构：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 interface show geometry_msgs/msg/Twist</code></pre><ul><li>发布话题消息：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 topic pub <topic_name> <msg_type> '<args>'    #这里的 ‘<args>’就是具体的消息内容啦，我们需要使用YAML的语法来描述，比如要发布速度指令Twist:    #–once表示这个消息只发布一次就退出。    ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 2.0, z: 2.0}, angular: {x: 0, y: 0, z: 2.0}}"    #持续发布    #–rate参数就表示频率啦，单位是hz    ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}"</code></pre><ul><li>查看话题消息的发布频率：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 topic hz /turtle1/pose</code></pre><h2 id="四、服务相关指令"><a href="#四、服务相关指令" class="headerlink" title="四、服务相关指令"></a>四、服务相关指令</h2><ul><li>列出服务：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 service list    ros2 service list -t</code></pre><ul><li>查看服务的数据结构：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 service type <service_name></code></pre><ul><li>查找提供某类型数据的所有服务:</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 service find <type_name>        ros2 service find std_srvs/srv/Empty</code></pre><ul><li>查看服务数据类型的具体结构:</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 interface show <type_name>.srv    ros2 interface show std_srvs/srv/Empty.srv</code></pre><ul><li>通过终端发送服务请求：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 service call <service_name> <service_type> <arguments>    ros2 service call /clear std_srvs/srv/Empty    ros2 service call /spawn turtlesim/srv/Spawn "{x: 2, y: 2, theta: 0.2, name: ''}"</code></pre><h2 id="五、参数服务相关指令"><a href="#五、参数服务相关指令" class="headerlink" title="五、参数服务相关指令"></a>五、参数服务相关指令</h2><ul><li>查看参数列表：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 param list</code></pre><ul><li>获取参数值：</li></ul><pre><code>    ros2 param get &lt;node_name&gt; &lt;parameter_name&gt;    ros2 param get /turtlesim background_g</code></pre><ul><li>设置参数值：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 param set <node_name> <parameter_name> <value>    ros2 param set /turtlesim background_r 150</code></pre><ul><li>保存参数：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 param dump <node_name>    ros2 param dump /turtlesim</code></pre><ul><li>加载参数文件：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 run <package_name> <executable_name> --ros-args --params-file <file_name>    ros2 run turtlesim turtlesim_node --ros-args --params-file ./turtlesim.yaml</code></pre><h2 id="六、Action相关指令"><a href="#六、Action相关指令" class="headerlink" title="六、Action相关指令"></a>六、Action相关指令</h2><ul><li>查看action列表：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 action list    ros2 action list -t</code></pre><ul><li>查看action信息：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 action info /turtle1/rotate_absolute</code></pre><ul><li>查看action数据类型：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 interface show turtlesim/action/RotateAbsolute.action</code></pre><ul><li>命令行发送action目标：</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">    ros2 action send_goal <action_name> <action_type> <values>    #<values>同样是YAML格式描述的数据。发送一个试试：    ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute "{theta: 1.57}"    #如果先要看到action中的周期反馈，以上命令还需要加一个–feedback参数：    ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute "{theta: -1.57}" --feedback</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> ROS2, Bash。 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用ZYNQ实现单LUT内容的动态修改（二）PS端动态修改LUT内容，软件部分，Vitis操作</title>
      <link href="/myblogs/2020/10/23/blog4-lut-nei-rong-du-qu-2/"/>
      <url>/myblogs/2020/10/23/blog4-lut-nei-rong-du-qu-2/</url>
      
        <content type="html"><![CDATA[<p>该系统的软件部分使用Xilinx Vitis平台进行实现，操作方法类似于之前版本的SDK，不同的是Vitis中的硬件平台要自己手动导入，其余编译调试大体相同。<br><a id="more"></a></p><h2 id="一，摘要"><a href="#一，摘要" class="headerlink" title="一，摘要"></a>一，摘要</h2><p>该篇博客主要记录软件端的整个流程，主要依据官方给出的HW_ICAP驱动库进行开发。具体硬件原理方面的知识不做太多介绍。有需要的话可以参考官方的一些手册。</p><h2 id="二，程序流程"><a href="#二，程序流程" class="headerlink" title="二，程序流程"></a>二，程序流程</h2><p>程序循环执行以下四种操作，</p><ol><li>输入FAR寄存器值，读取对应地址的数据帧。</li><li>输入要修改的LUT的位置，该位置可通过生成硬件时的Layout找出。</li><li>输入要修改LUT的新数据。将修改过的数据帧写入FPGA内部。</li><li>重新读出数据帧，与写入的数据帧进行对比，完全一致即返回修改成功，返回操作1。<h2 id="三，工程的建立与调试"><a href="#三，工程的建立与调试" class="headerlink" title="三，工程的建立与调试"></a>三，工程的建立与调试</h2>主要记录一些关键步骤！<h3 id="第一步，导入上篇博客生成的硬件平台"><a href="#第一步，导入上篇博客生成的硬件平台" class="headerlink" title="第一步，导入上篇博客生成的硬件平台"></a>第一步，导入上篇博客生成的硬件平台</h3>导入上篇博客工程目录下的xsa文件。<br><img src="https://img-blog.csdnimg.cn/20200225213224296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><br>接下来编译该硬件平台。<br><img src="https://img-blog.csdnimg.cn/202002252136222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><h3 id="第二步，导入并编译修改单LUT的程序"><a href="#第二步，导入并编译修改单LUT的程序" class="headerlink" title="第二步，导入并编译修改单LUT的程序"></a>第二步，导入并编译修改单LUT的程序</h3>导入.\src\vitis\目录下的C语言源文件，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200225220537262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt></li></ol><p>接下来需要注意官方的驱动有个BUG，针对于ZYNQ系列的器件，其DeviceIDCode并没有在7系列里面包含，这就使得在执行XHwIcap_CfgInitialize（）函数时出错，所以在此处要将其ID号改成7系列列表中有的ID号，如下图239行所示。<br><img src="https://img-blog.csdnimg.cn/20200225220055114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt></p><h3 id="第三步，调试工程。"><a href="#第三步，调试工程。" class="headerlink" title="第三步，调试工程。"></a>第三步，调试工程。</h3><p>右击工程选择Debug As/DebugConfiguration,然后设置如下图，点击调试。<br><img src="https://img-blog.csdnimg.cn/20200225221150746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><br>此时我们把top2.bit文件下载到FPGA部分，可以看到其LUT的输出内容如下图，<br><img src="https://img-blog.csdnimg.cn/20200225221001606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><br>通过串口助手输入FAR地址字段，对FPGA内部该地址的配置帧进行读取。<br><img src="https://img-blog.csdnimg.cn/20200225221744292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><br>截取部分读出的配置数据如下图所示，可在转换过后的rbt文件中找到该配置帧的数据。<br>我们需要操作的目标LUT的前1/4配置数据为下图中0x55550000这一数据，我们此时要对其进行更改。<br><img src="https://img-blog.csdnimg.cn/20200225221900112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><br>首先我们要输入该LUT数据在该帧数据中的位置08（此位置可以通过layout看出来）。<br><img src="https://img-blog.csdnimg.cn/20200225222329137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><br>进一步输入要修改成的数据，如下图所示，正常情况下返回Success即为写入成功。<br><img src="https://img-blog.csdnimg.cn/20200225222354507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><br>最终我们再来看一下该LUT输出的波形如下，可以看出其内部数据已经被修改了。<br><img src="https://img-blog.csdnimg.cn/2020022522262754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt></p><h2 id="四、中间遇到的问题"><a href="#四、中间遇到的问题" class="headerlink" title="四、中间遇到的问题"></a>四、中间遇到的问题</h2><ol><li>读帧数据时显示不完整，后小部分出现0xfffffffd,此种情况是由于AXI_ICAP ip的读FIFO容量设置太小造成的，中间会有部分数据缺失。解决办法，调大读FIFO的容量。</li><li>写帧数据时写不进去，经排查发现为设置正确的DeviceID号，改正后问题解决。</li><li>配置数据与LUT实际存储内容的映射关系还没来得及整清楚，看后面是否用得到。<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2>基本打通了单LUT读写的底层通路，为后面重构控制器的设计打下了基础。考虑通过云端等接口实现远程LUT内容的读写等操作，基于此可实现FPGA内部错误的自修复，高效重构任务的执行等高级功能。<h2 id="六、附程序代码如下"><a href="#六、附程序代码如下" class="headerlink" title="六、附程序代码如下"></a>六、附程序代码如下</h2></li></ol><pre class=" language-lang-c"><code class="language-lang-c">#include <stdlib.h>#include <stdio.h>#include <string.h>#include "xparameters.h"#include "xil_printf.h"#include "xil_cache.h"#include "ff.h"#include "xdevcfg.h"#include "xhwicap.h"#include "xil_io.h"#include "xil_types.h"#define PYNQ#define FRAME_WORDS_NUM    202// Parameters for Partial Reconfiguration#ifdef PYNQ#define READ_FRAME_SIZE 30#define WRITE_FRAME_SIZE 91#define PARTIAL_MULT_ADDR   0x200000#define PARTIAL_ADDER_ADDR   0x300000#define PARTIAL_BLANK_ADDR   0x400000#define PARTIAL_MULT_BITFILE_LEN  0xC66F // in number of words#define PARTIAL_ADDER_BITFILE_LEN  0xC66F // in number of words#define PARTIAL_BLANK_BITFILE_LEN  0xC66F // in number of words#endif// Turn on/off Debug messages#ifdef DEBUG_PRINT#define  debug_printf  xil_printf#else#define  debug_printf(msg, args...) do {  } while (0)#endif// Read function for STDINextern char inbyte(void);// Driver Instantiationsstatic XDcfg_Config *XDcfg_0;XDcfg DcfgInstance;XDcfg *DcfgInstPtr;static XHwIcap HwIcap;    // The instance of the HWICAP deviceXHwIcap *HwIcapInstPtr;uint32_t read_FrameBuffer[FRAME_WORDS_NUM];uint32_t read_FrameBuffer_verify[FRAME_WORDS_NUM];unsigned char uartBuffer[16];uint32_t addr_word;    //FAR Word.uint32_t new_word;    //The word to be writen to lut;uint32_t lut_index;    //int XHwIcap_DeviceReadFrame1(XHwIcap *InstancePtr, uint32_t far_word , u32 *FrameBuffer){    u32 Packet;    u32 Data;    u32 TotalWords;    int Status;    u32 WriteBuffer[WRITE_FRAME_SIZE];    u32 Index = 0;    u32 NumNoops;    Xil_AssertNonvoid(InstancePtr != NULL);    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);    Xil_AssertNonvoid(FrameBuffer != NULL);    /*     * DUMMY and SYNC     */    WriteBuffer[Index++] = XHI_DUMMY_PACKET;    WriteBuffer[Index++] = XHI_BUS_WTH_PACKET;    WriteBuffer[Index++] = XHI_BUS_DET_PACKET;    WriteBuffer[Index++] = XHI_DUMMY_PACKET;    WriteBuffer[Index++] = XHI_SYNC_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    /*     * Reset CRC     */    Packet = XHwIcap_Type1Write(XHI_CMD) | 1;    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = XHI_CMD_RCRC;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    /*     * Setup CMD register to read configuration     */    Packet = XHwIcap_Type1Write(XHI_CMD) | 1;    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = XHI_CMD_RCFG;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    /*     * Setup FAR register.     */    Packet = XHwIcap_Type1Write(XHI_FAR) | 1;    Data = far_word;    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = Data;    /*     * Setup read data packet header.     * The frame will be preceeded by a dummy frame, and we need to read one     * extra word for V4 and V5 devices.     */    switch (InstancePtr->DeviceFamily) {        case DEVICE_TYPE_7SERIES :                TotalWords = InstancePtr->WordsPerFrame << 1;                NumNoops = 32;                break;        case DEVICE_TYPE_ULTRA :            TotalWords = (InstancePtr->WordsPerFrame << 1) + 10;            NumNoops = 64;                break;        case DEVICE_TYPE_ULTRA_PLUS :            TotalWords = (InstancePtr->WordsPerFrame << 1) + 25;            NumNoops = 64;                break;        default:            return XST_FAILURE;    }    /*     * Create Type one packet     */    Packet = XHwIcap_Type1Read(XHI_FDRO);    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = 0x48000000 | TotalWords;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    for(unsigned int i = 0; i < NumNoops; i++) {        WriteBuffer[Index++] = XHI_NOOP_PACKET;    }    /*     * Write the data to the FIFO and initiate the transfer of data     * present in the FIFO to the ICAP device     */    Status = XHwIcap_DeviceWrite(InstancePtr, (u32 *)&WriteBuffer[0],            Index);    if (Status != XST_SUCCESS)  {        return XST_FAILURE;    }    /*     * Wait till the write is done.     */    while (XHwIcap_IsDeviceBusy(InstancePtr) != FALSE);    /*     * Read the frame of the data including the NULL frame.     */    Status = XHwIcap_DeviceRead(InstancePtr, FrameBuffer, TotalWords);    if (Status != XST_SUCCESS)  {        return XST_FAILURE;    }    /*     * Send DESYNC command     */    Status = XHwIcap_CommandDesync(InstancePtr);    if (Status != XST_SUCCESS)  {        return XST_FAILURE;    }    return XST_SUCCESS;};int XHwIcap_DeviceWriteFrame1(XHwIcap *InstancePtr, u32 far_word,                u32 *FrameData){    u32 Packet;    u32 Data;    u32 TotalWords;    int Status;    u32 WriteBuffer[READ_FRAME_SIZE];    u32 Index =0;    Xil_AssertNonvoid(InstancePtr != NULL);    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);    Xil_AssertNonvoid(FrameData != NULL);    /*     * DUMMY and SYNC     */    WriteBuffer[Index++] = XHI_DUMMY_PACKET;    WriteBuffer[Index++] = XHI_SYNC_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    /*     * Reset CRC     */    Packet = XHwIcap_Type1Write(XHI_CMD) | 1;    Data = XHI_CMD_RCRC;    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = Data;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    /*     * Bypass CRC     */    /*     * ID register     */    Packet = XHwIcap_Type1Write(XHI_IDCODE) | 1;    Data = InstancePtr->DeviceIdCode;    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = Data;    /*     * Setup FAR     */    Packet = XHwIcap_Type1Write(XHI_FAR) | 1;    Data = far_word;    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = Data;    /*     * Setup CMD register - write configuration     */    Packet = XHwIcap_Type1Write(XHI_CMD) | 1;    Data = XHI_CMD_WCFG;    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = Data;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    /*     * Setup Packet header.     */    TotalWords = InstancePtr->WordsPerFrame << 1;    if (TotalWords < XHI_TYPE_1_PACKET_MAX_WORDS)  {        /*         * Create Type 1 Packet.         */        Packet = XHwIcap_Type1Write(XHI_FDRI) | TotalWords;        WriteBuffer[Index++] = Packet;    }    else {        /*         * Create Type 2 Packet.         */        Packet = XHwIcap_Type1Write(XHI_FDRI);        WriteBuffer[Index++] = Packet;        Packet = XHI_TYPE_2_WRITE | TotalWords;        WriteBuffer[Index++] = Packet;    }    /*     * Write the Header data into the FIFO and intiate the transfer of     * data present in the FIFO to the ICAP device     */    Status = XHwIcap_DeviceWrite(InstancePtr, (u32 *)&WriteBuffer[0], Index);    if (Status != XST_SUCCESS)  {        return XST_FAILURE;    }    /*     * Write the modified frame data.     */    Status = XHwIcap_DeviceWrite(InstancePtr,                (u32 *) &FrameData[InstancePtr->WordsPerFrame],                InstancePtr->WordsPerFrame);    if (Status != XST_SUCCESS) {        return XST_FAILURE;    }    /*     * Write out the pad frame. The pad frame was read from the device     * before the data frame.     */    Status = XHwIcap_DeviceWrite(InstancePtr, (u32 *) &FrameData[0],                    InstancePtr->WordsPerFrame);    if (Status != XST_SUCCESS) {        return XST_FAILURE;    }    /* Add CRC */    Index = 0;    Packet = XHwIcap_Type1Write(XHI_CMD) | 1;    Data = XHI_CMD_RCRC;    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = Data;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    /* Park the FAR */    Packet = XHwIcap_Type1Write(XHI_FAR) | 1;    Data = XHwIcap_SetupFar(0, 0, 3, 33, 0);    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] =  Data;    /* Add CRC */    Packet = XHwIcap_Type1Write(XHI_CMD) | 1;    Data = XHI_CMD_RCRC;    WriteBuffer[Index++] = Packet;    WriteBuffer[Index++] = Data;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    WriteBuffer[Index++] = XHI_NOOP_PACKET;    /*     * Intiate the transfer of data present in the FIFO to     * the ICAP device     */    Status = XHwIcap_DeviceWrite(InstancePtr, &WriteBuffer[0], Index);    if (Status != XST_SUCCESS)  {        return XST_FAILURE;    }    /*     * Send DESYNC command     */    Status = XHwIcap_CommandDesync(InstancePtr);    if (Status != XST_SUCCESS) {        return XST_FAILURE;    }    return XST_SUCCESS;};u32 getWord (){    unsigned char byte;    int digitIndex;    u32 far_word;    while(1){        byte = 0x00;        digitIndex = 0;        //get bytes from uart until RETURN is entered        while(byte != 0x0d){            byte = inbyte();            uartBuffer[digitIndex] = byte;            xil_printf("%x", byte);            digitIndex++;        }        xil_printf("\r\n");        if(digitIndex==5)        {            far_word = uartBuffer[0]<<24 | uartBuffer[1]<<16 |uartBuffer[2]<<8 | uartBuffer[3];            return far_word;        }        else        {            digitIndex =0 ;            break;        }    }}u32 getByte (){    unsigned char byte;    int digitIndex;    u32 data;    while(1){        byte = 0x00;        digitIndex = 0;        //get bytes from uart until RETURN is entered        while(byte != 0x0d){            byte = inbyte();            uartBuffer[digitIndex] = byte;            xil_printf("%x\r\n", byte);            digitIndex++;        }        if(digitIndex==2)        {            data = uartBuffer[0];            return data;        }    }}int main(){    int Status;    int i;    int equal_number;    XHwIcap_Config *ConfigPtr;    // Flush and disable Data Cache    Xil_DCacheDisable();    // Invalidate and enable Data Cache    Xil_DCacheEnable();    // Initialize Device Configuration Interface    DcfgInstPtr = &DcfgInstance;    XDcfg_0 = XDcfg_LookupConfig(XPAR_XDCFG_0_DEVICE_ID) ;    Status =  XDcfg_CfgInitialize(DcfgInstPtr, XDcfg_0, XDcfg_0->BaseAddr);    if (Status != XST_SUCCESS) {        return XST_FAILURE;    }    // Deselect PCAP as the configuration device as we are going to use the ICAP    XDcfg_ClearControlRegister(DcfgInstPtr, XDCFG_CTRL_PCAP_PR_MASK);    ConfigPtr = XHwIcap_LookupConfig(XPAR_AXI_HWICAP_0_DEVICE_ID);    if (ConfigPtr == NULL) {        return XST_FAILURE;    }    HwIcapInstPtr = &HwIcap;    Status = XHwIcap_CfgInitialize(HwIcapInstPtr, ConfigPtr,                ConfigPtr->BaseAddress);    if (Status != XST_SUCCESS) {        return XST_FAILURE;    }    HwIcapInstPtr->DeviceIdCode = 0x23727093;    XHwIcap_Reset(HwIcapInstPtr);    print("HWICAP Initialized\r\n");    while(1)    {        equal_number=0;        print("Please input the far words!\r\n");        addr_word = getWord();        Status = XHwIcap_DeviceReadFrame1(HwIcapInstPtr, addr_word,&read_FrameBuffer[0]);        XHwIcap_Reset(HwIcapInstPtr);        if (Status != XST_SUCCESS) {            print("Read Lut Failure\r\n");            return XST_FAILURE;        }        else if(Status == XST_SUCCESS)        {            for(i=0;i<FRAME_WORDS_NUM;i++)                xil_printf("%x\r\n",read_FrameBuffer[i]);        }        print("Please input the number of the lut:\r\n");        lut_index = getByte();        print("Please input the new data of the lut:\r\n");        new_word = getWord();        read_FrameBuffer[(101 + lut_index)] = new_word;        Status = XHwIcap_DeviceWriteFrame1(HwIcapInstPtr, addr_word, &read_FrameBuffer[1]);        XHwIcap_Reset(HwIcapInstPtr);        if (Status != XST_SUCCESS) {            print("Write Lut Failure\r\n");            return XST_FAILURE;        }        Status = XHwIcap_DeviceReadFrame1(HwIcapInstPtr, addr_word,read_FrameBuffer_verify);        if (Status != XST_SUCCESS) {            print("Read Lut Failure\r\n");            return XST_FAILURE;        }        for(i=0;i<FRAME_WORDS_NUM;i++)        {            if(read_FrameBuffer_verify[i] == read_FrameBuffer[i])            {                equal_number ++;            }        }        if(equal_number != 202)            print("Write Lut Failure!\r\n");        else            print("Write Lut Success!\r\n");    }    return 0;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> FPGA, ZYNQ, Vitis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用ZYNQ实现单LUT内容的动态修改（一）PL端OOC设计流程</title>
      <link href="/myblogs/2020/10/23/blog3-lut-nei-rong-du-qu-1/"/>
      <url>/myblogs/2020/10/23/blog3-lut-nei-rong-du-qu-1/</url>
      
        <content type="html"><![CDATA[<p>本文主要用于记录作者本人实现ZYNQ动态修改LUT内容过程中主要参考的资料，实现的步骤，遇到的问题等。主要参考的文章链接如下：<a href="https://cloud.tencent.com/developer/article/1528881，其中该工作大部分的原理部分该篇博客都有介绍，本篇博客不再赘述。" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1528881，其中该工作大部分的原理部分该篇博客都有介绍，本篇博客不再赘述。</a><br><a id="more"></a></p><h2 id="一，摘要"><a href="#一，摘要" class="headerlink" title="一，摘要"></a>一，摘要</h2><p>主要介绍一下<strong>使用Vivado进行部分动态重构系统的开发流程</strong>，<strong>AXI_HWICAP IP基本的使用方法</strong>，以及<strong>通过ARM部分实现LUT内容动态修改的程序流程(此部分见下篇博客)</strong>。</p><h2 id="二，系统框图"><a href="#二，系统框图" class="headerlink" title="二，系统框图"></a>二，系统框图</h2><p><img src="https://img-blog.csdnimg.cn/20200225180357207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt="系统框图"><br>系统结构主要如上图，其中LUT的读写操作由PS端的程序控制，通过PC端的串口助手可以观察读取的配置帧数据，设置要修改的LUT位置以及修改后的LUT中的新数据。</p><h2 id="三，PL工程的创建，综合，布局布线。"><a href="#三，PL工程的创建，综合，布局布线。" class="headerlink" title="三，PL工程的创建，综合，布局布线。"></a>三，PL工程的创建，综合，布局布线。</h2><p>考虑到调试过程中可能要多次设置目标LUT的初始值来搞清楚bitstream中数据与LUT中数据的映射关系，为了<strong>提高该系统的编译调试效率，本文针对目标操作的LUT采取局部动态重构的设计方法</strong>。实际应用中不采用部分重构设计流程也可以对LUT进行动态读写。<br>以下是本次设计使用Vivado进行部分重构系统开发的整体流程：</p><ol><li>使用Vivado创建整个设计，将部分重构模块保留为空模块。综合工程生成静态设计的.dcp文件(如top_syn_static.dcp)。</li><li>综合部分重构模块的源文件，生成对应的.dcp文件(如：pr_lut_syn.dcp)。</li><li>打开第一步生成的top_syn_static.dcp，读入第二步生成的pr_lut_syn.dcp，设置重构属性，保存设计点。</li><li>为重构模块指定重构区域，读入约束文件。</li><li>优化，布局，布线，保存设计点。</li><li>生成bitstream文件，及ila调试相关文件。</li><li>将重构模块清除保留为黑盒，将其他部分在布局布线后的级别上保存其设计点。</li><li>打开上一步保存的设计点，读入新的重构模块，优化，布局布线，保存设计点，生成bitstream等。</li><li>使用pr_verify指令对生成的bitstream进行验证。<h3 id="第一步，创建设计。"><a href="#第一步，创建设计。" class="headerlink" title="第一步，创建设计。"></a>第一步，创建设计。</h3>可直接在给出的工程目录下面执行脚本自动创建，综合，以及硬件的导出。在工程目录下执行以下代码(windows下需要在Vivado的命令行下操作)：<pre class=" language-lang-javascript"><code class="language-lang-javascript">source ./tcl/step1_create_project.tcl</code></pre>具体工程文件结构如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200225173307967.png" alt="工程结构"><br>其中原理图部分如下：<br><img src="https://img-blog.csdnimg.cn/20200225173451606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt="原理图"><br>这一步我们要<strong>用到的文件为.\vivado\lut_modify.runs\synth_1\top.dcp，我们需要将此文件复制到.\checkpoints\synth\static\路径下</strong>，便于后续操作。<br>当然也可以自己手动来创建工程，编写相关文件。<h3 id="第二步，综合重构模块"><a href="#第二步，综合重构模块" class="headerlink" title="第二步，综合重构模块"></a>第二步，综合重构模块</h3>直接执行脚本文件即可，脚本代码如下：<pre class=" language-lang-javascript"><code class="language-lang-javascript">read_verilog ./src/rms/pr_lut1/pr_lut.vsynth_design -mode out_of_context -flatten_hierarchy rebuilt -top pr_lut -part xc7z020clg400-1write_checkpoint ./checkpoints/synth/rms/pr_lut1.dcpclose_designclose_project</code></pre>以下是重构模块的verilog代码，该模块例化一个内部的固定位置的LUT，便于我们以后寻址更改其内部内容：<pre class=" language-lang-verilog"><code class="language-lang-verilog">timescale 1ns/1ps //*******************//DEFINE MODULE PORT//*******************module  pr_lut   (               input           clk  ,          input           rst  ,          input   [5:0]   din  ,          output  reg     dout                     ) ;//*********************//INNER SIGNAL DECLARATION//*********************//REGSreg [5:0] din_ff ;//WIRESwire  dout_pre ;//*********************//MAIN CORE//********************* always @(posedge clk or posedge rst) begin  if (rst == 1'b1) begin      din_ff <= 'd0 ;  end  else begin      din_ff <= din ;  endendalways @(posedge clk or posedge rst) begin  if (rst == 1'b1) begin      dout <= 'd0 ;  end  else begin      dout <= dout_pre ;  endend// 0001 0010 0011(* DONT_TOUCH= "TRUE" *) (*BEL="D6LUT",LOC="SLICE_X57Y53"*)    LUT6 #(    .INIT(64'h1234123412341234)  // Specify LUT Contents  ) LUT6_inst_D_right (    .O(dout_pre),   // LUT general output    .I0(din_ff[0]), // LUT input    .I1(din_ff[1]), // LUT input    .I2(din_ff[2]), // LUT input    .I3(din_ff[3]), // LUT input    .I4(din_ff[4]), // LUT input    .I5(din_ff[5])  // LUT input );//*********************endmodule</code></pre></li></ol><p>该步操作主要生成的文件如下图,后面可用不同lut初始值的rm来创建完整设计，方便在bitstream文件中找到目标lut配置数据的位置及内容。便于分析bitstream配置数据同实际LUT中数据的映射关系：<br><img src="https://img-blog.csdnimg.cn/20200225180557292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt="rms"></p><h3 id="第三步，打开设计点，读入重构模块，划分重构区域"><a href="#第三步，打开设计点，读入重构模块，划分重构区域" class="headerlink" title="第三步，打开设计点，读入重构模块，划分重构区域"></a>第三步，打开设计点，读入重构模块，划分重构区域</h3><p>执行以下脚本</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">open_checkpoint ./checkpoints/synth/static/top.dcpread_checkpoint -cell pr_lut_0 ./checkpoints/synth/rms/pr_lut1.dcpset_property HD.RECONFIGURABLE 1 [get_cells pr_lut_0]  write_checkpoint ./checkpoints/synth/top_link_lut.dcp -force #划分重构区域。startgroupcreate_pblock pblock_pr_lut_0resize_pblock pblock_pr_lut_0 -add {SLICE_X54Y50:SLICE_X59Y59 RAMB18_X3Y20:RAMB18_X3Y23 RAMB36_X3Y10:RAMB36_X3Y11}add_cells_to_pblock pblock_pr_lut_0 [get_cells [list pr_lut_0]] -clear_locsendgroup</code></pre><p>其中为重构模块划分重构区域手动操作如下图，然后在layout上面绘制相应的重构区域即可，注意：此例中由于指定了LUT的位置信息，所以重构区域必须覆盖到该LUT的物理区域。<br><img src="https://img-blog.csdnimg.cn/20200225181803384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt="划分重构区域"><br>此例中划分的重构区域如下：<br><img src="https://img-blog.csdnimg.cn/20200225182306433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt="重构区域"></p><h3 id="第四步，优化，布局布线，保存设计点，生成-bit及-rbt文件。"><a href="#第四步，优化，布局布线，保存设计点，生成-bit及-rbt文件。" class="headerlink" title="第四步，优化，布局布线，保存设计点，生成.bit及.rbt文件。"></a>第四步，优化，布局布线，保存设计点，生成.bit及.rbt文件。</h3><p>直接执行以下命令：</p><pre class=" language-lang-bash"><code class="language-lang-bash">opt_design place_design route_designwrite_checkpoint -force ./checkpoints/implement/top_route_design.dcp write_checkpoint -force -cell pr_lut_0 ./checkpoints/implement/pr_lut_instance_route_design.dcpwrite_bitstream  -raw_bitfile ./bitstreams/top1 -forcewrite_debug_probes -force ./bitstreams/top</code></pre><p>执行上述命令后可以观察到器件已经完成布局布线，此时可生成对应的bitstream文件及部分bitstream文件。我们可通过生成的top.rbt来分析top.bit的结构，（<strong>top.rbt为top.bit的二进制asii格式表示，可通过python脚本来将rbt文件转换为16进制格式表示数据并保存为txt文件，后续我们从器件中读配置数据的时候要与之进行对比，来验证读操作的正确性</strong>）<br><img src="https://img-blog.csdnimg.cn/20200225184904323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt="布局布线结果"></p><h3 id="第五步，保存静态设计。"><a href="#第五步，保存静态设计。" class="headerlink" title="第五步，保存静态设计。"></a>第五步，保存静态设计。</h3><p>脚本命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">update_design -cell pr_lut_0 -black_boxlock_design -level routingwrite_checkpoint -force ./checkpoints/routed/static_route_design.dcpupdate_design -buffer_ports -cell pr_lut_0place_designroute_designwrite_checkpoint -force ./checkpoints/implement/top_route_design.dcpclose_project</code></pre><h3 id="第六步，读入新的重构模块，生成的完整bit文件及部分bit文件。"><a href="#第六步，读入新的重构模块，生成的完整bit文件及部分bit文件。" class="headerlink" title="第六步，读入新的重构模块，生成的完整bit文件及部分bit文件。"></a>第六步，读入新的重构模块，生成的完整bit文件及部分bit文件。</h3><p>脚本和上面操作多有重复，这里不再给出。<br><strong>本操作的意义在于利用前面保存过的静态设计，载入新的重构模块进行综合，布局布线，大大减少了整个工程综合，布局布线的时间成本。</strong><br>针对此次设计任务需求，需要多次更改目标LUT的初始值，采用此种设计流程能够大大减少后期bitstream文件的生成时间，而不必牵一发而动全身，每次都浪费这么长的时间来进行类似的操作。</p><h3 id="第七步，验证两个设计是否兼容。"><a href="#第七步，验证两个设计是否兼容。" class="headerlink" title="第七步，验证两个设计是否兼容。"></a>第七步，验证两个设计是否兼容。</h3><p>脚本命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">pr_verify -initial ./checkpoints/implement/top_route_design.dcp  -additional {./checkpoints/implement/top_route_design2.dcp }close_project</code></pre><p>验证结果如下图<br><img src="https://img-blog.csdnimg.cn/20200225195512172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt="验证结果"><br>至此整个重构系统基于Vivado的脱离上下文的设计流程结束。</p><h2 id="四、AXI-HWICAP相关信息"><a href="#四、AXI-HWICAP相关信息" class="headerlink" title="四、AXI_HWICAP相关信息"></a>四、AXI_HWICAP相关信息</h2><p>相关寄存器如下表：<br><img src="https://img-blog.csdnimg.cn/20200225201034277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt="reg1"><br><img src="https://img-blog.csdnimg.cn/20200225201056262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><br><img src="https://img-blog.csdnimg.cn/20200225201138870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70" alt><br>读写配置：<br>1)    将bitstream写进写FIFO寄存器进行配置。<br>2)    从读FIFO寄存器读取配置bitstream。<br>3)    向CR寄存器写值去启动bitstream的读取或写入，控制寄存器决定了数据传输的方向。向控制寄存器写入0x00000001开始写配置。写0x00000002开始读配置。<br>4)    状态寄存器的Done位表明了ICAPEn接口是否处于忙碌状态，并不代表读配置或写配置是否成功完成。<br>5)    在成功进行读或者写配置之后硬件清零CR寄存器。<br>6)    在CR寄存器未被清零的情况下，软件不能初始化另一个读或写配置操作。</p><p>精简模式下写序列：<br>1)    将指令写进写FIFO寄存器进行配置。<br>2)    向控制寄存器写控制字初始化写指令。<br>3)    成功完成配置后硬件清零控制寄存器位。<br>4)    向写FIFO寄存器写入第二个指令，写控制字执行向ICAPEn端口的写操作。<br>5)    继续执行上述操作直到所有指令被写到ICAPEn端口。</p><p>中止：<br>1)    向控制寄存器写控制字开始bitstream读写。<br>2)    将bitstream写入到FIFO寄存器执行配置，从读FIFO寄存器获取读取到的bitstream。<br>3)    向控制寄存器的第五位写1来执行中止。<br>4)    状态寄存器的Done位显示了ICAPEn端口是否正处于忙碌状态，不表示读，写操作成功完成。<br>5)    在成功执行中止操作后硬件清零控制寄存器位。<br>6)    在CR寄存器未被清零的情况下，软件不能初始化另一个读或写配置操作。</p><p>注意：<br>1)    <strong>帧是配置数据允许被读或写的最小粒度。</strong><br>2)    <strong>修改单个LUT内容必须读出整帧，修改后再将整帧数据读入。</strong></p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇博客主要记录了使用Vivado工具进行脱离上下文(Out Of Context)方式进行开发的流程。<strong>以本篇生成的硬件系统为基础，可以进一步通过PS端的软件编程来实现对目标LUT的内容进行修改，亦可通过软件来为PR区域加载不同的重构模块来实现FPGA内部电路的动态重构。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> FPGA, ZYNQ, LUT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adam论文翻译</title>
      <link href="/myblogs/2020/08/13/blog2-adam-lun-wen-fan-yi/"/>
      <url>/myblogs/2020/08/13/blog2-adam-lun-wen-fan-yi/</url>
      
        <content type="html"><![CDATA[<p>本文为Adam算法原论文的翻译。<br><a id="more"></a></p><h2 id="第一部分：引言"><a href="#第一部分：引言" class="headerlink" title="第一部分：引言"></a>第一部分：引言</h2><p>​    基于随机梯度的优化问题在许多科学和工程领域具有重要的实际意义。这些领域中的许多问题都可以归结为某个标量参数化目标函数的优化问题，这些目标函数要求对其参数进行最大化或最小化。如果函数的参数是可微的，梯度下降法是一种比较有效的优化方法，因为计算一阶偏导数w.r.t.的所有参数都与计算函数的计算复杂度相同。通常，目标函数是随机的。在这种情况下，可以用多个随机子函数组成的梯度函数或多个梯度子函数组成。SGD被证明是一种高效、有效的优化方法，在许多机器学习成功案例中起着核心作用，例如深度学习的最新进展（Deng等人，2013；Krizhevsky等人，2012；Hinton&amp;Salakhutdinov，2006；Hinton et al.，2012a；Graves et al.，2013）。目标也可能有数据子采样以外的其他噪声源，如辍学（Hinton等人，2012b）正则化。对于所有这些噪声目标，需要有效的随机优化技术。本文主要研究具有高维参数空间的随机目标优化问题。在这些情况下，高阶优化方法不适合，本文的讨论将局限于一阶方法。</p><p>​    我们提出了Adam，一种只需要一阶梯度且内存需求很少的高效随机优化方法。该方法根据梯度的一阶矩和二阶矩的估计来计算不同参数的个体自适应学习率；Adam的名字来源于自适应矩估计。我们的方法结合了最近流行的两种方法的优点：AdaGrad（Duchi et al.，2011）和RMSProp（Tieleman&amp;Hinton，2012），这两种方法在在线和非平稳环境下工作良好；第5节阐明了这些方法和其他随机优化方法的重要联系。Adam的一些优点是参数更新的大小对梯度的重定标是不变的，它的步长是由步长超参数近似限定的，它不需要一个平稳的目标，它与稀疏梯度一起工作，并且它自然地执行一种步长退火的形式。</p><hr><p><strong>算法1：</strong> $g_t^2$代表元素平方$g_t \bigodot g_t$，被测试机器学习问题的良好的默认设置参数为$\alpha = 0.001, \beta_1=0.9,\beta_2=0.99$ 以及$\epsilon=10^{-8}$。对向量所有的操作都是基于元素的。对于$\beta_1^t 与\beta_2^t$表示$\beta_1 \beta_2$的t次方。</p><hr><p>$ \bf{Require: } \quad\alpha:\; Stepsize$</p><p>$\bf{Require:} \quad\beta_1,\beta_2\in[0,1): \;  Exponential\;decay\; rates\; for\; the\; moment\; estimates$</p><p>$ \bf{Require: } \quad f(\theta):\; Stochastic\; objective\; function\; with\; parameters\; \theta $</p><p>$ \bf{Require: } \quad\theta_0:\; Initial\; parameter\; vector $</p><p>$\qquad m_0 \leftarrow 0 (Initialize\; 1^{st} \;moment \; vector) $</p><p>$\qquad v_0 \leftarrow 0 (Initialize\; 2^{nd} \;moment \; vector) $</p><p>$\qquad t \leftarrow 0 (Initialize\; timestep) $</p><p>$\qquad \bf{while} \;\theta_t \; not\; converged \; \bf{do} $</p><p>$\qquad \qquad t \leftarrow t+1 $</p><p>$\qquad \qquad g_t \leftarrow  \nabla_{\theta}f_t(\theta_t-1) \;(Get\; gradients\; w.r.t.\; stochastic\; objective\; at\; timestep\; t) $</p><p>$\qquad \qquad m_t \leftarrow \beta_1 \cdot m_{t-1} +(1-\beta_1)\cdot g_t \;(Update\; biased\; first\; moment\; estimate) $</p><p>$\qquad \qquad v_t \leftarrow \beta_2 \cdot v_{t-1} +(1-\beta_2)\cdot g_t^2 \;(Update\; biased\; second\; raw\; moment\; estimate) $</p><p>$\qquad \qquad \hat{m_t} \leftarrow m_t/(1-\beta_1^t) \;(Compute\; bias-corrected\; first\; moment\; estimate) $</p><p>$\qquad \qquad \hat{v_t} \leftarrow v_t/(.1-\beta_2^t) \;(Compute\; bias-corrected\; second\; raw \; moment\; estimate) $</p><p>$\qquad \qquad \theta_t \leftarrow \theta{t-1} - \alpha\cdot \hat{m_t}/(\sqrt{\hat v_t} +\epsilon ) \;(Update \; parameters)$</p><p>$\qquad \bf{end\; while}$</p><p>$\qquad \bf{return} \; \theta_t \;(Resulting \; parameters) $</p><hr><p>​    第二节介绍了算法及其更新规则的性质。第3节介绍了我们的初始化偏差校正技术，第4节对在线凸规划中的Adam收敛性进行了理论分析。从经验上讲，我们的方法在各种模型和数据集上始终优于其他方法，如第6节所示。总的来说，我们证明了Adam是一个多功能的算法，可以扩展到大规模的高维机器学习问题。</p><h2 id="第二部分：算法"><a href="#第二部分：算法" class="headerlink" title="第二部分：算法"></a>第二部分：算法</h2><p>​    我们提出的算法Adam的伪代码见算法1。设$f(\theta)$是一个有噪声的目标函数：一个可微$w.r.t.$参数$ \theta$的随机标量函数。我们感兴趣的是最小化这个函数的期望值，$\mathbb{E}[f(\theta)]\,w.r.t. $它的参数$\theta$。用$f_1(\theta), \cdots, f_T(\theta) $表示随机函数在随后的时间步骤$1，\cdots，T$的实现。随机性可能来自于对数据点的随机子样本（小批量）的评估，也可能来自固有的函数噪声。用$g_t=\bigtriangledown_{\theta}f_t(\theta)$表示梯度，即在时间步长t处计算的$f_t，w.r.t\;\theta$的偏导数向量。</p><p>​    该算法更新梯度$m_t$和平方梯度$v_t$的指数移动平均，其中超参数$β_1，β_2\in[0，1）$控制这些移动平均的指数衰减率。移动平均值本身就是梯度的第一个矩（平均值）和第二个原始矩（无中心方差）的估计值。然而，这些移动平均值被初始化为（向量）0，导致矩估计值偏向于零，特别是在初始时间步长期间，尤其是当衰减率很小（即$\beta_s$接近1）时。好消息是，这种初始化偏差可以很容易地抵消，从而得到偏差校正的估计值$\hat m_t$和$\hat v_t$。有关更多详细信息，请参阅第3节。</p><p>​    注意，算法1的效率可以通过改变计算顺序（例如，用下面的行替换循环中的最后三行）来提高算法1的效率:</p><script type="math/tex; mode=display">\alpha_t=\frac {\alpha \cdot \sqrt{1-\beta^t_2}}{(1-\beta^t_1)}</script><script type="math/tex; mode=display">\theta_t = \theta_{t-1}-\frac{\alpha_t\cdot m_t}{(\sqrt{v_t}+\hat \epsilon )}</script><h3 id="2-1-Adam更新率"><a href="#2-1-Adam更新率" class="headerlink" title="2.1 Adam更新率"></a>2.1 Adam更新率</h3><p>​    Adam更新规则的一个重要属性是它对步长的谨慎选择。假设$\epsilon =0$，时间步长t在参数空间中采取的有效步骤为$\Delta_t=\alpha\cdot \frac{\hat m_t}{\sqrt{\hat v_t}}. $</p><p>有效步长有两个上界：在$(1-\beta_1)&gt;\sqrt{1-\beta_2}$的情况下$\left|\Delta_{t}\right| \leq \alpha \cdot\left(1-\beta_{1}\right) / \sqrt{1-\beta_{2}}  $,以及$\left|\Delta_{t}\right| \leq \alpha$。否则,第一种情况只发生在最严重的稀疏情况下：梯度在除当前时间步以外的所有时间步上都为零。对于较少稀疏的情况，有效步长将更小。当$\left(1-\beta_{1}\right)=\sqrt{1-\beta_{2}}$情况下，有$\left|\hat{m}_{t} / \sqrt{\hat{v}_{t}}\right|&lt;1$因此$\left|\Delta_{t}\right|&lt;\alpha$。在更普通的场景中，因为$|\mathbb{E}[g] / \sqrt{\mathbb{E}\left[g^{2}\right]}| \leq 1$我们有$\widehat{m}_{t} / \sqrt{\widehat{v}_{t}} \approx \pm 1$ .每个时间步在参数空间中所采取的有效步长近似为步长设置α的范围，即$\left|\Delta_{t}\right| \leqq \alpha$。这可以理解为在当前参数值周围建立一个信任区域，超过该区域，当前梯度估计无法提供足够的信息。这通常使得提前知道α的正确刻度相对容易。例如，对于许多机器学习模型，我们通常预先知道好的最优解在参数空间的某个集合区域内具有高概率；例如，对参数具有先验分布的情况并不少见。由于α在参数空间中设置了步长（的上界），我们通常可以推导出α的正确量级，从而在一定的迭代次数内从$\theta_0$到达最优值。稍加滥用术语，我们将比率$\hat{m}_{t} / \sqrt{\widehat{v}_{t}}$称为信噪比$（SNR）$。信噪比越小，有效步长$∆t$将更接近于零。这是一个理想的特性，因为较小的信噪比意味着$\hat m_t$的方向是否与真实梯度的方向相对应存在更大的不确定性。例如，$SNR$值通常会向最优值靠拢，从而导致参数空间中的有效步长更小：这是自动退火的一种形式。有效步长$∆t$也与梯度的比例不变性；用系数c重新缩放梯度g将用系数c缩放$\hat{m}_{t}$，用系数$c^2$缩放$\hat{v}_{t}$这抵消了$\hat{m}_{t} / \sqrt{\widehat{v}_{t}}\left(c \cdot \hat{m}_{t}\right) /(\sqrt{c^{2} \cdot \hat{v}_{t}})=\hat{m}_{t} / \sqrt{\hat{v}_{t}}$。</p><h2 id="第三部分：初始化偏差校正"><a href="#第三部分：初始化偏差校正" class="headerlink" title="第三部分：初始化偏差校正"></a>第三部分：初始化偏差校正</h2><p>​    如第2节所述，Adam使用初始化偏差校正项。我们将在这里导出二阶矩估计的项；一阶矩估计的推导完全类似。设g是随机目标f的梯度，我们希望用平方梯度的指数移动平均估计其第二原始矩（无中心方差），衰减率为$β2$。设$g_1，\cdots，g_T$为后续时间步的梯度，每个都是从基本梯度分布$g_t∼p(gT)$中提取的。让我们将指数移动平均值初始化为$v_0=0$（零向量）。首先注意指数移动平均值$v_{t}=\beta_{2} \cdot v_{t-1}+\left(1-\beta_{2}\right) \cdot g_{t}^{2}$（其中$g_t^2$表明了元素平方$g_t\odot g_t$）在时间步长t处的更新可以写成所有先前时间步长的梯度函数：</p><script type="math/tex; mode=display">v_{t}=\left(1-\beta_{2}\right) \sum_{i=1}^{t} \beta_{2}^{t-i} \cdot g_{i}^{2} \tag{1}</script><p>​    我们想知道时间步长t处指数移动平均值的期望值$\mathbb{E}\left[v_{t}\right]$是如何与真实的第二时刻$\mathbb{E}\left[g_{t}^2\right]$相关的，因此我们可以纠正两者之间的差异。取等式（1）左右两侧的期望值：</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}\left[v_{t}\right] &=\mathbb{E}\left[\left(1-\beta_{2}\right) \sum_{i=1}^{t} \beta_{2}^{t-i} \cdot g_{i}^{2}\right] \\&=\mathbb{E}\left[g_{t}^{2}\right] \cdot\left(1-\beta_{2}\right) \sum_{i=1}^{t} \beta_{2}^{t-i}+\zeta \\&=\mathbb{E}\left[g_{t}^{2}\right] \cdot\left(1-\beta_{2}^{t}\right)+\zeta\end{aligned}</script><p>​    式中：$ζ=0$，如果真实第二力矩$\mathbb{E}\left[g_{i}^2\right]$是静止的；否则，$ζ$可以保持较小，因为指数衰减率$β1$可以（并且应该）被选择为指数移动平均为过去太远的梯度分配小权重。剩下的是项$（1−β_t)$，这是由用零初始化运行平均值引起的。因此，在算法1中，我们用这个项来修正初始化偏差。</p><p>​    在稀疏梯度的情况下，为了可靠地估计二阶矩，需要通过选择较小的$β2$值对许多梯度进行平均；然而，正是在小$β2$的情况下，缺少初始化偏差校正将导致初始步骤大得多。</p><h2 id="第四部分：收敛性分析"><a href="#第四部分：收敛性分析" class="headerlink" title="第四部分：收敛性分析"></a>第四部分：收敛性分析</h2><p>​    我们使用（Zinkevich，2003）提出的在线学习框架来分析Adam的收敛性。给定凸代价函数$f_1（θ），f_2（θ），\cdots，f_T（θ）$的任意未知序列。在每个时刻$t$，我们的目标是预测参数$θ_t$，并在先前未知的代价函数$f_t$上对其进行评估。由于序列的性质是预先未知的，因此我们使用遗憾来评估我们的算法，即在线预测$f_t(θt)$与来自前面所有步骤的可行集$\mathcal{X}$。具体地说，遗憾是指：</p><script type="math/tex; mode=display">R(T)=\sum_{t=1}^{T}\left[f_{t}\left(\theta_{t}\right)-f_{t}\left(\theta^{*}\right)\right] \tag{5}</script><p>​    其中$\theta^{*}=\arg \min _{\theta \in \mathcal{X}} \sum_{t=1}^{T} f_{t}(\theta)$。我们证明Adam没有遗憾边界，并在附录中给出了证明。我们的结果与一般凸在线学习问题的已知界相当。我们还使用一些定义来简化我们的符号，其中$g_{t} \triangleq \nabla f_{t}\left(\theta_{t}\right)$和$g_{t,i}$作为第i个元素。我们将$g_{1: t, i} \in \mathbb{R}^{t}$定义为一个向量，它包含所有迭代过程中梯度的第i维，直到t，$g_{1: t, i}=\left[g_{1, i}, g_{2, i}, \cdots, g_{t, i}\right]$。同样，我们定义$\gamma \triangleq \frac{\beta_{1}^{2}}{\sqrt{\beta_{2}}}$。当学习速率$α_t$以$t-1$的速率衰减时，我们的以下定理成立，并且第一时刻平均系数$β_{1,t}$以$λ$指数衰减，通常接近1，例如$1-10^{-8}$。</p><hr><p><strong>定理4.1</strong>. 假设函数ft具有有界梯度，$\left|\nabla f_{t}(\theta)\right|_{2} \leq G,\left|\nabla f_{t}(\theta)\right|_{\infty} \leqq G_{\infty}$对于所有的$\theta \in R^{d }$并且Adam生成的任何$θt$之间的距离是有界的，$\left|\theta_{n}-\theta_{m}\right|_{2} \leq D, \left|\theta_{m}-\theta_{n}\right|_{\infty} \leq D_{\infty}$对于任何$m, n \in\{1, \ldots, T\}, \text { and } \beta_{1}, \beta_{2} \in[0,1)$满足$\frac{\beta_{1}^{2}}{\sqrt{\beta_{2}}}&lt;1$，让$\alpha_{t}=\frac{\alpha}{\sqrt{t}}$并且$\beta_{1, t}=\beta_{1} \lambda^{t-1}, \lambda \in(0,1)$。Adam对于所有$T≥1$达到以下保证。</p><script type="math/tex; mode=display">R(T) \leq \frac{D^{2}}{2 \alpha\left(1-\beta_{1}\right)} \sum_{i=1}^{d} \sqrt{T \hat{v}_{T, i}}+\frac{\alpha\left(1+\beta_{1}\right) G_{\infty}}{\left(1-\beta_{1}\right) \sqrt{1-\beta_{2}}(1-\gamma)^{2}} \sum_{i=1}^{d}\left\|g_{1: T, i}\right\|_{2}+\sum_{i=1}^{d} \frac{D_{\infty}^{2} G_{\infty} \sqrt{1-\beta_{2}}}{2 \alpha\left(1-\beta_{1}\right)(1-\lambda)^{2}}</script><hr><p>我们的定理4.1表明，当数据特征是稀疏且有界梯度时，求和项可以远小于其上限$\sum_{i=1}^{d}\left|g_{1: T, i}\right|_{2}&lt;&lt;d G_{\infty} \sqrt{T}$并且$\sum_{i=1}^{d} \sqrt{T \widehat{v}_{T, i}}&lt;&lt;d G_{\infty} \sqrt{T}$,尤其是如果函数和数据特征的类别是第1.2节(Duchi等人，2011）的形式。他们对期望值$\mathbb{E}\left[\sum_{i=1}^{d}\left|g_{1: T, i}\right|_{2}\right]$的结果也适用于Adam。通常，类似于Adam与Adagrad的自适应方法，可以实现$O(\log d \sqrt{T})$相比于非自适应方法计算复杂度$O(\sqrt{d T})$的改进。在我们的理论分析中，将$β_{1,t}$衰减为零是很重要的，也与以前的经验结果相吻合，例如（Sutskever等人，2013年）表明在训练结束时降低动量系数可以提高收敛性。最后，我们可以展示Adam的平均遗憾.</p><hr><p><strong>推论4.2.</strong>假设函数$f_t$具有有界梯度，$\left|\nabla f_{t}(\theta)\right|_{2} \leq G,\left|\nabla f_{t}(\theta)\right|_{\infty} \leq G_{\infty} \text { for all } \theta \in R^{d}$并且Adam生成的任何$θt$之间的距离是有界的，$\left|\theta_{n}-\theta_{m}\right|_{2} \leq D,\left|\theta_{m}-\theta_{n}\right|_{\infty} \leq D_{\infty}$对任意的$m, n \in\{1, \ldots, T\}$。Adam达到以下保证，对于所有$T≥1$。</p><script type="math/tex; mode=display">\frac{R(T)}{T}=O\left(\frac{1}{\sqrt{T}}\right)</script><p>利用定理4.1和$\sum_{i=1}^{d}\left|g_{1: T, i}\right|_{2} \leq d G_{\infty} \sqrt{T}$可以得到这个结果。因此，$\lim _{T \rightarrow \infty} \frac{R(T)}{T}=0$。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Adam, 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下安装hexo并部署网站</title>
      <link href="/myblogs/2020/08/04/blog1-an-zhuang-hexo-yi-ji-wang-zhan-de-bu-shu/"/>
      <url>/myblogs/2020/08/04/blog1-an-zhuang-hexo-yi-ji-wang-zhan-de-bu-shu/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍在Windows操作系统上使用hexo生成个人博客的软件安装及环境配置，同时记录了过程中用到的相关命令。<br><a id="more"></a></p><h2 id="一、安装node-js"><a href="#一、安装node-js" class="headerlink" title="一、安装node.js"></a>一、安装node.js</h2><p>windows版本的官网链接为：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> ，<strong>安装过程中CustomSetup这一步记得检查Add—to-PATH是否被选上。</strong> 安装完成后命令行输入以下命令检查环境是否配好，正常情况下会返回软件版本号。</p><pre><code>npm -v</code></pre><h2 id="二、安装hexo"><a href="#二、安装hexo" class="headerlink" title="二、安装hexo"></a>二、安装hexo</h2><p>在Windows的cmd命令行中输入以下命令安装hexo并验证。</p><pre><code>npm install -g hexohexo -v</code></pre><p>如果出现以下错误：</p><pre><code>hexo : 无法加载文件 C:\Users\45478\AppData\Roaming\npm\hexo.ps1，因为在此系统上禁止运行脚本。</code></pre><p>可在管理员模式下的powershell中执行以下命令，输入y回车，之后问题解决。</p><pre><code>set-ExecutionPolicy RemoteSigned</code></pre><h2 id="三、生成博客"><a href="#三、生成博客" class="headerlink" title="三、生成博客"></a>三、生成博客</h2><p>步骤为创建工作目录，工作目录初始化，生成博客，开启本地服务预览网站。指令代码如下。</p><pre><code>hexo inithexo generate  hexo server</code></pre><h2 id="四、部署网站"><a href="#四、部署网站" class="headerlink" title="四、部署网站"></a>四、部署网站</h2><ul><li>首先执行以下命令安装hexo-deployer-git。</li></ul><pre><code>npm install hexo-deployer-git --save</code></pre><ul><li>网站的部署可以参考<a href="https://hexo.io/zh-cn/docs/one-command-deployment" target="_blank" rel="noopener">hexo</a>的官方教程，主要用到的命令如下。</li></ul><pre><code>hexo deploy</code></pre><ul><li>deploy之前需要更改_config.yml中deploy段的参数，可使用多个deployer。</li></ul><pre><code>deploy:- type: git  repo:- type: heroku  repo:</code></pre><ul><li>修改配置。</li></ul><pre><code>deploy:  type: git  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io  branch: [branch]  message: [message]</code></pre><ul><li>生成站点文件并推送至远程库。执行以下指令<pre><code>hexo clean hexo deploy</code></pre><h2 id="五、HEXO主题"><a href="#五、HEXO主题" class="headerlink" title="五、HEXO主题"></a>五、HEXO主题</h2>可以<a href="https://hexo.io/themes/" target="_blank" rel="noopener">在官网的主题页面</a>找适合自己的主题，本文所用的主题为<a href="https://volantis.js.org/" target="_blank" rel="noopener">volantis</a>，在此对主题的作者表示崇高的敬意！！!<br><img src="https://s1.ax1x.com/2020/08/05/arQSld.png" alt="volantis主题封面"></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> hexo, 部署网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/myblogs/2020/07/22/hello-world/"/>
      <url>/myblogs/2020/07/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
