{"meta":{"title":"Jian's Blog","subtitle":"","description":"","author":"SongChenjian","url":"http://cj_song.gitee.io/myblogs","root":"/myblogs/"},"pages":[{"title":"404 Not Found","date":"2020-08-13T10:47:36.295Z","updated":"2020-08-06T08:02:32.253Z","comments":true,"path":"404.html","permalink":"http://cj_song.gitee.io/myblogs/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"关于","date":"2020-08-13T10:53:15.655Z","updated":"2020-08-13T10:53:08.083Z","comments":true,"path":"about/index.html","permalink":"http://cj_song.gitee.io/myblogs/about/index.html","excerpt":"","text":"name宋晨健 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"所有分类","date":"2020-08-13T10:53:15.658Z","updated":"2020-08-13T10:52:37.004Z","comments":true,"path":"categories/index.html","permalink":"http://cj_song.gitee.io/myblogs/categories/index.html","excerpt":"","text":"test document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-08-06T07:20:00.000Z","updated":"2020-08-06T07:24:08.792Z","comments":true,"path":"contact/index.html","permalink":"http://cj_song.gitee.io/myblogs/contact/index.html","excerpt":"","text":"test document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2020-08-13T10:47:36.321Z","updated":"2020-07-11T06:22:21.000Z","comments":true,"path":"mylist/index.html","permalink":"http://cj_song.gitee.io/myblogs/mylist/index.html","excerpt":"","text":"test document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"我的朋友们","date":"2020-08-13T11:11:51.428Z","updated":"2020-08-13T11:11:15.953Z","comments":true,"path":"friends/index.html","permalink":"http://cj_song.gitee.io/myblogs/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"所有标签","date":"2020-08-13T11:12:27.147Z","updated":"2020-08-13T11:11:33.182Z","comments":true,"path":"tags/index.html","permalink":"http://cj_song.gitee.io/myblogs/tags/index.html","excerpt":"","text":"test document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"使用ZYNQ实现单LUT内容的动态修改（二）PS端动态修改LUT内容，软件部分，Vitis操作","slug":"blog4_LUT内容读取2","date":"2020-10-23T08:00:00.000Z","updated":"2020-10-23T07:58:31.462Z","comments":true,"path":"2020/10/23/blog4-lut-nei-rong-du-qu-2/","link":"","permalink":"http://cj_song.gitee.io/myblogs/2020/10/23/blog4-lut-nei-rong-du-qu-2/","excerpt":"该系统的软件部分使用Xilinx Vitis平台进行实现，操作方法类似于之前版本的SDK，不同的是Vitis中的硬件平台要自己手动导入，其余编译调试大体相同。","text":"该系统的软件部分使用Xilinx Vitis平台进行实现，操作方法类似于之前版本的SDK，不同的是Vitis中的硬件平台要自己手动导入，其余编译调试大体相同。 一，摘要该篇博客主要记录软件端的整个流程，主要依据官方给出的HW_ICAP驱动库进行开发。具体硬件原理方面的知识不做太多介绍。有需要的话可以参考官方的一些手册。 二，程序流程程序循环执行以下四种操作， 输入FAR寄存器值，读取对应地址的数据帧。 输入要修改的LUT的位置，该位置可通过生成硬件时的Layout找出。 输入要修改LUT的新数据。将修改过的数据帧写入FPGA内部。 重新读出数据帧，与写入的数据帧进行对比，完全一致即返回修改成功，返回操作1。三，工程的建立与调试主要记录一些关键步骤！第一步，导入上篇博客生成的硬件平台导入上篇博客工程目录下的xsa文件。接下来编译该硬件平台。第二步，导入并编译修改单LUT的程序导入.\\src\\vitis\\目录下的C语言源文件，如下图所示。 接下来需要注意官方的驱动有个BUG，针对于ZYNQ系列的器件，其DeviceIDCode并没有在7系列里面包含，这就使得在执行XHwIcap_CfgInitialize（）函数时出错，所以在此处要将其ID号改成7系列列表中有的ID号，如下图239行所示。 第三步，调试工程。右击工程选择Debug As/DebugConfiguration,然后设置如下图，点击调试。此时我们把top2.bit文件下载到FPGA部分，可以看到其LUT的输出内容如下图，通过串口助手输入FAR地址字段，对FPGA内部该地址的配置帧进行读取。截取部分读出的配置数据如下图所示，可在转换过后的rbt文件中找到该配置帧的数据。我们需要操作的目标LUT的前1/4配置数据为下图中0x55550000这一数据，我们此时要对其进行更改。首先我们要输入该LUT数据在该帧数据中的位置08（此位置可以通过layout看出来）。进一步输入要修改成的数据，如下图所示，正常情况下返回Success即为写入成功。最终我们再来看一下该LUT输出的波形如下，可以看出其内部数据已经被修改了。 四、中间遇到的问题 读帧数据时显示不完整，后小部分出现0xfffffffd,此种情况是由于AXI_ICAP ip的读FIFO容量设置太小造成的，中间会有部分数据缺失。解决办法，调大读FIFO的容量。 写帧数据时写不进去，经排查发现为设置正确的DeviceID号，改正后问题解决。 配置数据与LUT实际存储内容的映射关系还没来得及整清楚，看后面是否用得到。五、总结基本打通了单LUT读写的底层通路，为后面重构控制器的设计打下了基础。考虑通过云端等接口实现远程LUT内容的读写等操作，基于此可实现FPGA内部错误的自修复，高效重构任务的执行等高级功能。六、附程序代码如下 #include #include #include #include \"xparameters.h\" #include \"xil_printf.h\" #include \"xil_cache.h\" #include \"ff.h\" #include \"xdevcfg.h\" #include \"xhwicap.h\" #include \"xil_io.h\" #include \"xil_types.h\" #define PYNQ #define FRAME_WORDS_NUM 202 // Parameters for Partial Reconfiguration #ifdef PYNQ #define READ_FRAME_SIZE 30 #define WRITE_FRAME_SIZE 91 #define PARTIAL_MULT_ADDR 0x200000 #define PARTIAL_ADDER_ADDR 0x300000 #define PARTIAL_BLANK_ADDR 0x400000 #define PARTIAL_MULT_BITFILE_LEN 0xC66F // in number of words #define PARTIAL_ADDER_BITFILE_LEN 0xC66F // in number of words #define PARTIAL_BLANK_BITFILE_LEN 0xC66F // in number of words #endif // Turn on/off Debug messages #ifdef DEBUG_PRINT #define debug_printf xil_printf #else #define debug_printf(msg, args...) do { } while (0) #endif // Read function for STDIN extern char inbyte(void); // Driver Instantiations static XDcfg_Config *XDcfg_0; XDcfg DcfgInstance; XDcfg *DcfgInstPtr; static XHwIcap HwIcap; // The instance of the HWICAP device XHwIcap *HwIcapInstPtr; uint32_t read_FrameBuffer[FRAME_WORDS_NUM]; uint32_t read_FrameBuffer_verify[FRAME_WORDS_NUM]; unsigned char uartBuffer[16]; uint32_t addr_word; //FAR Word. uint32_t new_word; //The word to be writen to lut; uint32_t lut_index; // int XHwIcap_DeviceReadFrame1(XHwIcap *InstancePtr, uint32_t far_word , u32 *FrameBuffer) { u32 Packet; u32 Data; u32 TotalWords; int Status; u32 WriteBuffer[WRITE_FRAME_SIZE]; u32 Index = 0; u32 NumNoops; Xil_AssertNonvoid(InstancePtr != NULL); Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY); Xil_AssertNonvoid(FrameBuffer != NULL); /* * DUMMY and SYNC */ WriteBuffer[Index++] = XHI_DUMMY_PACKET; WriteBuffer[Index++] = XHI_BUS_WTH_PACKET; WriteBuffer[Index++] = XHI_BUS_DET_PACKET; WriteBuffer[Index++] = XHI_DUMMY_PACKET; WriteBuffer[Index++] = XHI_SYNC_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; /* * Reset CRC */ Packet = XHwIcap_Type1Write(XHI_CMD) | 1; WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = XHI_CMD_RCRC; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; /* * Setup CMD register to read configuration */ Packet = XHwIcap_Type1Write(XHI_CMD) | 1; WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = XHI_CMD_RCFG; WriteBuffer[Index++] = XHI_NOOP_PACKET; /* * Setup FAR register. */ Packet = XHwIcap_Type1Write(XHI_FAR) | 1; Data = far_word; WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = Data; /* * Setup read data packet header. * The frame will be preceeded by a dummy frame, and we need to read one * extra word for V4 and V5 devices. */ switch (InstancePtr->DeviceFamily) { case DEVICE_TYPE_7SERIES : TotalWords = InstancePtr->WordsPerFrame < 1; NumNoops = 32; break; case DEVICE_TYPE_ULTRA : TotalWords = (InstancePtr->WordsPerFrame < 1) + 10; NumNoops = 64; break; case DEVICE_TYPE_ULTRA_PLUS : TotalWords = (InstancePtr->WordsPerFrame < 1) + 25; NumNoops = 64; break; default: return XST_FAILURE; } /* * Create Type one packet */ Packet = XHwIcap_Type1Read(XHI_FDRO); WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = 0x48000000 | TotalWords; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; for(unsigned int i = 0; i < NumNoops; i++) { WriteBuffer[Index++] = XHI_NOOP_PACKET; } /* * Write the data to the FIFO and initiate the transfer of data * present in the FIFO to the ICAP device */ Status = XHwIcap_DeviceWrite(InstancePtr, (u32 *)&WriteBuffer[0], Index); if (Status != XST_SUCCESS) { return XST_FAILURE; } /* * Wait till the write is done. */ while (XHwIcap_IsDeviceBusy(InstancePtr) != FALSE); /* * Read the frame of the data including the NULL frame. */ Status = XHwIcap_DeviceRead(InstancePtr, FrameBuffer, TotalWords); if (Status != XST_SUCCESS) { return XST_FAILURE; } /* * Send DESYNC command */ Status = XHwIcap_CommandDesync(InstancePtr); if (Status != XST_SUCCESS) { return XST_FAILURE; } return XST_SUCCESS; }; int XHwIcap_DeviceWriteFrame1(XHwIcap *InstancePtr, u32 far_word, u32 *FrameData) { u32 Packet; u32 Data; u32 TotalWords; int Status; u32 WriteBuffer[READ_FRAME_SIZE]; u32 Index =0; Xil_AssertNonvoid(InstancePtr != NULL); Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY); Xil_AssertNonvoid(FrameData != NULL); /* * DUMMY and SYNC */ WriteBuffer[Index++] = XHI_DUMMY_PACKET; WriteBuffer[Index++] = XHI_SYNC_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; /* * Reset CRC */ Packet = XHwIcap_Type1Write(XHI_CMD) | 1; Data = XHI_CMD_RCRC; WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = Data; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; /* * Bypass CRC */ /* * ID register */ Packet = XHwIcap_Type1Write(XHI_IDCODE) | 1; Data = InstancePtr->DeviceIdCode; WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = Data; /* * Setup FAR */ Packet = XHwIcap_Type1Write(XHI_FAR) | 1; Data = far_word; WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = Data; /* * Setup CMD register - write configuration */ Packet = XHwIcap_Type1Write(XHI_CMD) | 1; Data = XHI_CMD_WCFG; WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = Data; WriteBuffer[Index++] = XHI_NOOP_PACKET; /* * Setup Packet header. */ TotalWords = InstancePtr->WordsPerFrame < 1; if (TotalWords < XHI_TYPE_1_PACKET_MAX_WORDS) { /* * Create Type 1 Packet. */ Packet = XHwIcap_Type1Write(XHI_FDRI) | TotalWords; WriteBuffer[Index++] = Packet; } else { /* * Create Type 2 Packet. */ Packet = XHwIcap_Type1Write(XHI_FDRI); WriteBuffer[Index++] = Packet; Packet = XHI_TYPE_2_WRITE | TotalWords; WriteBuffer[Index++] = Packet; } /* * Write the Header data into the FIFO and intiate the transfer of * data present in the FIFO to the ICAP device */ Status = XHwIcap_DeviceWrite(InstancePtr, (u32 *)&WriteBuffer[0], Index); if (Status != XST_SUCCESS) { return XST_FAILURE; } /* * Write the modified frame data. */ Status = XHwIcap_DeviceWrite(InstancePtr, (u32 *) &FrameData[InstancePtr->WordsPerFrame], InstancePtr->WordsPerFrame); if (Status != XST_SUCCESS) { return XST_FAILURE; } /* * Write out the pad frame. The pad frame was read from the device * before the data frame. */ Status = XHwIcap_DeviceWrite(InstancePtr, (u32 *) &FrameData[0], InstancePtr->WordsPerFrame); if (Status != XST_SUCCESS) { return XST_FAILURE; } /* Add CRC */ Index = 0; Packet = XHwIcap_Type1Write(XHI_CMD) | 1; Data = XHI_CMD_RCRC; WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = Data; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; /* Park the FAR */ Packet = XHwIcap_Type1Write(XHI_FAR) | 1; Data = XHwIcap_SetupFar(0, 0, 3, 33, 0); WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = Data; /* Add CRC */ Packet = XHwIcap_Type1Write(XHI_CMD) | 1; Data = XHI_CMD_RCRC; WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = Data; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; /* * Intiate the transfer of data present in the FIFO to * the ICAP device */ Status = XHwIcap_DeviceWrite(InstancePtr, &WriteBuffer[0], Index); if (Status != XST_SUCCESS) { return XST_FAILURE; } /* * Send DESYNC command */ Status = XHwIcap_CommandDesync(InstancePtr); if (Status != XST_SUCCESS) { return XST_FAILURE; } return XST_SUCCESS; }; u32 getWord (){ unsigned char byte; int digitIndex; u32 far_word; while(1){ byte = 0x00; digitIndex = 0; //get bytes from uart until RETURN is entered while(byte != 0x0d){ byte = inbyte(); uartBuffer[digitIndex] = byte; xil_printf(\"%x\", byte); digitIndex++; } xil_printf(\"\\r\\n\"); if(digitIndex==5) { far_word = uartBuffer[0]","categories":[],"tags":[{"name":"FPGA, ZYNQ, Vitis","slug":"FPGA-ZYNQ-Vitis","permalink":"http://cj_song.gitee.io/myblogs/tags/FPGA-ZYNQ-Vitis/"}]},{"title":"使用ZYNQ实现单LUT内容的动态修改（一）PL端OOC设计流程","slug":"blog3_LUT内容读取1","date":"2020-10-23T07:00:00.000Z","updated":"2020-10-23T07:58:10.049Z","comments":true,"path":"2020/10/23/blog3-lut-nei-rong-du-qu-1/","link":"","permalink":"http://cj_song.gitee.io/myblogs/2020/10/23/blog3-lut-nei-rong-du-qu-1/","excerpt":"本文主要用于记录作者本人实现ZYNQ动态修改LUT内容过程中主要参考的资料，实现的步骤，遇到的问题等。主要参考的文章链接如下：https://cloud.tencent.com/developer/article/1528881，其中该工作大部分的原理部分该篇博客都有介绍，本篇博客不再赘述。","text":"本文主要用于记录作者本人实现ZYNQ动态修改LUT内容过程中主要参考的资料，实现的步骤，遇到的问题等。主要参考的文章链接如下：https://cloud.tencent.com/developer/article/1528881，其中该工作大部分的原理部分该篇博客都有介绍，本篇博客不再赘述。 一，摘要主要介绍一下使用Vivado进行部分动态重构系统的开发流程，AXI_HWICAP IP基本的使用方法，以及通过ARM部分实现LUT内容动态修改的程序流程(此部分见下篇博客)。 二，系统框图系统结构主要如上图，其中LUT的读写操作由PS端的程序控制，通过PC端的串口助手可以观察读取的配置帧数据，设置要修改的LUT位置以及修改后的LUT中的新数据。 三，PL工程的创建，综合，布局布线。考虑到调试过程中可能要多次设置目标LUT的初始值来搞清楚bitstream中数据与LUT中数据的映射关系，为了提高该系统的编译调试效率，本文针对目标操作的LUT采取局部动态重构的设计方法。实际应用中不采用部分重构设计流程也可以对LUT进行动态读写。以下是本次设计使用Vivado进行部分重构系统开发的整体流程： 使用Vivado创建整个设计，将部分重构模块保留为空模块。综合工程生成静态设计的.dcp文件(如top_syn_static.dcp)。 综合部分重构模块的源文件，生成对应的.dcp文件(如：pr_lut_syn.dcp)。 打开第一步生成的top_syn_static.dcp，读入第二步生成的pr_lut_syn.dcp，设置重构属性，保存设计点。 为重构模块指定重构区域，读入约束文件。 优化，布局，布线，保存设计点。 生成bitstream文件，及ila调试相关文件。 将重构模块清除保留为黑盒，将其他部分在布局布线后的级别上保存其设计点。 打开上一步保存的设计点，读入新的重构模块，优化，布局布线，保存设计点，生成bitstream等。 使用pr_verify指令对生成的bitstream进行验证。第一步，创建设计。可直接在给出的工程目录下面执行脚本自动创建，综合，以及硬件的导出。在工程目录下执行以下代码(windows下需要在Vivado的命令行下操作)：source ./tcl/step1_create_project.tcl 具体工程文件结构如下图所示：其中原理图部分如下：这一步我们要用到的文件为.\\vivado\\lut_modify.runs\\synth_1\\top.dcp，我们需要将此文件复制到.\\checkpoints\\synth\\static\\路径下，便于后续操作。当然也可以自己手动来创建工程，编写相关文件。第二步，综合重构模块直接执行脚本文件即可，脚本代码如下：read_verilog ./src/rms/pr_lut1/pr_lut.v synth_design -mode out_of_context -flatten_hierarchy rebuilt -top pr_lut -part xc7z020clg400-1 write_checkpoint ./checkpoints/synth/rms/pr_lut1.dcp close_design close_project 以下是重构模块的verilog代码，该模块例化一个内部的固定位置的LUT，便于我们以后寻址更改其内部内容：``javascripttimescale 1ns/1ps //*//DEFINE MODULE PORT//*module pr_lut ( input clk , input rst , input [5:0] din , output reg dout ) ; //*//INNER SIGNAL DECLARATION//*//REGSreg [5:0] din_ff ; //WIRES wire dout_pre ;//*//MAIN CORE//*always @(posedge clk or posedge rst) begin if (rst == 1’b1) begin din_ff &lt;= ‘d0 ; end else begin din_ff &lt;= din ; endend always @(posedge clk or posedge rst) begin if (rst == 1’b1) begin dout &lt;= ‘d0 ; end else begin dout &lt;= dout_pre ; endend// 0001 0010 0011 ( DONT_TOUCH= “TRUE” ) (BEL=”D6LUT”,LOC=”SLICE_X57Y53”) LUT6 #( .INIT(64’h1234123412341234) // Specify LUT Contents ) LUT6_inst_D_right ( .O(dout_pre), // LUT general output .I0(din_ff[0]), // LUT input .I1(din_ff[1]), // LUT input .I2(din_ff[2]), // LUT input .I3(din_ff[3]), // LUT input .I4(din_ff[4]), // LUT input .I5(din_ff[5]) // LUT input ); //*endmodule 该步操作主要生成的文件如下图,后面可用不同lut初始值的rm来创建完整设计，方便在bitstream文件中找到目标lut配置数据的位置及内容。便于分析bitstream配置数据同实际LUT中数据的映射关系： ![rms](https://img-blog.csdnimg.cn/20200225180557292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDg1OTA1,size_16,color_FFFFFF,t_70) ### 第三步，打开设计点，读入重构模块，划分重构区域 执行以下脚本 ```javascript open_checkpoint ./checkpoints/synth/static/top.dcp read_checkpoint -cell pr_lut_0 ./checkpoints/synth/rms/pr_lut1.dcp set_property HD.RECONFIGURABLE 1 [get_cells pr_lut_0] write_checkpoint ./checkpoints/synth/top_link_lut.dcp -force #划分重构区域。 startgroup create_pblock pblock_pr_lut_0 resize_pblock pblock_pr_lut_0 -add {SLICE_X54Y50:SLICE_X59Y59 RAMB18_X3Y20:RAMB18_X3Y23 RAMB36_X3Y10:RAMB36_X3Y11} add_cells_to_pblock pblock_pr_lut_0 [get_cells [list pr_lut_0]] -clear_locs endgroup 其中为重构模块划分重构区域手动操作如下图，然后在layout上面绘制相应的重构区域即可，注意：此例中由于指定了LUT的位置信息，所以重构区域必须覆盖到该LUT的物理区域。此例中划分的重构区域如下： 第四步，优化，布局布线，保存设计点，生成.bit及.rbt文件。直接执行以下命令： opt_design place_design route_design write_checkpoint -force ./checkpoints/implement/top_route_design.dcp write_checkpoint -force -cell pr_lut_0 ./checkpoints/implement/pr_lut_instance_route_design.dcp write_bitstream -raw_bitfile ./bitstreams/top1 -force write_debug_probes -force ./bitstreams/top 执行上述命令后可以观察到器件已经完成布局布线，此时可生成对应的bitstream文件及部分bitstream文件。我们可通过生成的top.rbt来分析top.bit的结构，（top.rbt为top.bit的二进制asii格式表示，可通过python脚本来将rbt文件转换为16进制格式表示数据并保存为txt文件，后续我们从器件中读配置数据的时候要与之进行对比，来验证读操作的正确性） 第五步，保存静态设计。脚本命令如下： update_design -cell pr_lut_0 -black_box lock_design -level routing write_checkpoint -force ./checkpoints/routed/static_route_design.dcp update_design -buffer_ports -cell pr_lut_0 place_design route_design write_checkpoint -force ./checkpoints/implement/top_route_design.dcp close_project 第六步，读入新的重构模块，生成的完整bit文件及部分bit文件。脚本和上面操作多有重复，这里不再给出。本操作的意义在于利用前面保存过的静态设计，载入新的重构模块进行综合，布局布线，大大减少了整个工程综合，布局布线的时间成本。针对此次设计任务需求，需要多次更改目标LUT的初始值，采用此种设计流程能够大大减少后期bitstream文件的生成时间，而不必牵一发而动全身，每次都浪费这么长的时间来进行类似的操作。 第七步，验证两个设计是否兼容。脚本命令如下： pr_verify -initial ./checkpoints/implement/top_route_design.dcp -additional {./checkpoints/implement/top_route_design2.dcp } close_project 验证结果如下图至此整个重构系统基于Vivado的脱离上下文的设计流程结束。 四、AXI_HWICAP相关信息相关寄存器如下表：读写配置：1) 将bitstream写进写FIFO寄存器进行配置。2) 从读FIFO寄存器读取配置bitstream。3) 向CR寄存器写值去启动bitstream的读取或写入，控制寄存器决定了数据传输的方向。向控制寄存器写入0x00000001开始写配置。写0x00000002开始读配置。4) 状态寄存器的Done位表明了ICAPEn接口是否处于忙碌状态，并不代表读配置或写配置是否成功完成。5) 在成功进行读或者写配置之后硬件清零CR寄存器。6) 在CR寄存器未被清零的情况下，软件不能初始化另一个读或写配置操作。 精简模式下写序列：1) 将指令写进写FIFO寄存器进行配置。2) 向控制寄存器写控制字初始化写指令。3) 成功完成配置后硬件清零控制寄存器位。4) 向写FIFO寄存器写入第二个指令，写控制字执行向ICAPEn端口的写操作。5) 继续执行上述操作直到所有指令被写到ICAPEn端口。 中止：1) 向控制寄存器写控制字开始bitstream读写。2) 将bitstream写入到FIFO寄存器执行配置，从读FIFO寄存器获取读取到的bitstream。3) 向控制寄存器的第五位写1来执行中止。4) 状态寄存器的Done位显示了ICAPEn端口是否正处于忙碌状态，不表示读，写操作成功完成。5) 在成功执行中止操作后硬件清零控制寄存器位。6) 在CR寄存器未被清零的情况下，软件不能初始化另一个读或写配置操作。 注意：1) 帧是配置数据允许被读或写的最小粒度。2) 修改单个LUT内容必须读出整帧，修改后再将整帧数据读入。 五、总结本篇博客主要记录了使用Vivado工具进行脱离上下文(Out Of Context)方式进行开发的流程。以本篇生成的硬件系统为基础，可以进一步通过PS端的软件编程来实现对目标LUT的内容进行修改，亦可通过软件来为PR区域加载不同的重构模块来实现FPGA内部电路的动态重构。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"FPGA, ZYNQ, LUT","slug":"FPGA-ZYNQ-LUT","permalink":"http://cj_song.gitee.io/myblogs/tags/FPGA-ZYNQ-LUT/"}]},{"title":"Adam论文翻译","slug":"blog2_Adam论文翻译","date":"2020-08-13T10:15:00.000Z","updated":"2020-08-13T11:23:31.078Z","comments":true,"path":"2020/08/13/blog2-adam-lun-wen-fan-yi/","link":"","permalink":"http://cj_song.gitee.io/myblogs/2020/08/13/blog2-adam-lun-wen-fan-yi/","excerpt":"本文为Adam算法原论文的翻译。","text":"本文为Adam算法原论文的翻译。 第一部分：引言​ 基于随机梯度的优化问题在许多科学和工程领域具有重要的实际意义。这些领域中的许多问题都可以归结为某个标量参数化目标函数的优化问题，这些目标函数要求对其参数进行最大化或最小化。如果函数的参数是可微的，梯度下降法是一种比较有效的优化方法，因为计算一阶偏导数w.r.t.的所有参数都与计算函数的计算复杂度相同。通常，目标函数是随机的。在这种情况下，可以用多个随机子函数组成的梯度函数或多个梯度子函数组成。SGD被证明是一种高效、有效的优化方法，在许多机器学习成功案例中起着核心作用，例如深度学习的最新进展（Deng等人，2013；Krizhevsky等人，2012；Hinton&amp;Salakhutdinov，2006；Hinton et al.，2012a；Graves et al.，2013）。目标也可能有数据子采样以外的其他噪声源，如辍学（Hinton等人，2012b）正则化。对于所有这些噪声目标，需要有效的随机优化技术。本文主要研究具有高维参数空间的随机目标优化问题。在这些情况下，高阶优化方法不适合，本文的讨论将局限于一阶方法。 ​ 我们提出了Adam，一种只需要一阶梯度且内存需求很少的高效随机优化方法。该方法根据梯度的一阶矩和二阶矩的估计来计算不同参数的个体自适应学习率；Adam的名字来源于自适应矩估计。我们的方法结合了最近流行的两种方法的优点：AdaGrad（Duchi et al.，2011）和RMSProp（Tieleman&amp;Hinton，2012），这两种方法在在线和非平稳环境下工作良好；第5节阐明了这些方法和其他随机优化方法的重要联系。Adam的一些优点是参数更新的大小对梯度的重定标是不变的，它的步长是由步长超参数近似限定的，它不需要一个平稳的目标，它与稀疏梯度一起工作，并且它自然地执行一种步长退火的形式。 算法1： $g_t^2$代表元素平方$g_t \\bigodot g_t$，被测试机器学习问题的良好的默认设置参数为$\\alpha = 0.001, \\beta_1=0.9,\\beta_2=0.99$ 以及$\\epsilon=10^{-8}$。对向量所有的操作都是基于元素的。对于$\\beta_1^t 与\\beta_2^t$表示$\\beta_1 \\beta_2$的t次方。 $ \\bf{Require: } \\quad\\alpha:\\; Stepsize$ $\\bf{Require:} \\quad\\beta_1,\\beta_2\\in[0,1): \\; Exponential\\;decay\\; rates\\; for\\; the\\; moment\\; estimates$ $ \\bf{Require: } \\quad f(\\theta):\\; Stochastic\\; objective\\; function\\; with\\; parameters\\; \\theta $ $ \\bf{Require: } \\quad\\theta_0:\\; Initial\\; parameter\\; vector $ $\\qquad m_0 \\leftarrow 0 (Initialize\\; 1^{st} \\;moment \\; vector) $ $\\qquad v_0 \\leftarrow 0 (Initialize\\; 2^{nd} \\;moment \\; vector) $ $\\qquad t \\leftarrow 0 (Initialize\\; timestep) $ $\\qquad \\bf{while} \\;\\theta_t \\; not\\; converged \\; \\bf{do} $ $\\qquad \\qquad t \\leftarrow t+1 $ $\\qquad \\qquad g_t \\leftarrow \\nabla_{\\theta}f_t(\\theta_t-1) \\;(Get\\; gradients\\; w.r.t.\\; stochastic\\; objective\\; at\\; timestep\\; t) $ $\\qquad \\qquad m_t \\leftarrow \\beta_1 \\cdot m_{t-1} +(1-\\beta_1)\\cdot g_t \\;(Update\\; biased\\; first\\; moment\\; estimate) $ $\\qquad \\qquad v_t \\leftarrow \\beta_2 \\cdot v_{t-1} +(1-\\beta_2)\\cdot g_t^2 \\;(Update\\; biased\\; second\\; raw\\; moment\\; estimate) $ $\\qquad \\qquad \\hat{m_t} \\leftarrow m_t/(1-\\beta_1^t) \\;(Compute\\; bias-corrected\\; first\\; moment\\; estimate) $ $\\qquad \\qquad \\hat{v_t} \\leftarrow v_t/(.1-\\beta_2^t) \\;(Compute\\; bias-corrected\\; second\\; raw \\; moment\\; estimate) $ $\\qquad \\qquad \\theta_t \\leftarrow \\theta{t-1} - \\alpha\\cdot \\hat{m_t}/(\\sqrt{\\hat v_t} +\\epsilon ) \\;(Update \\; parameters)$ $\\qquad \\bf{end\\; while}$ $\\qquad \\bf{return} \\; \\theta_t \\;(Resulting \\; parameters) $ ​ 第二节介绍了算法及其更新规则的性质。第3节介绍了我们的初始化偏差校正技术，第4节对在线凸规划中的Adam收敛性进行了理论分析。从经验上讲，我们的方法在各种模型和数据集上始终优于其他方法，如第6节所示。总的来说，我们证明了Adam是一个多功能的算法，可以扩展到大规模的高维机器学习问题。 第二部分：算法​ 我们提出的算法Adam的伪代码见算法1。设$f(\\theta)$是一个有噪声的目标函数：一个可微$w.r.t.$参数$ \\theta$的随机标量函数。我们感兴趣的是最小化这个函数的期望值，$\\mathbb{E}[f(\\theta)]\\,w.r.t. $它的参数$\\theta$。用$f_1(\\theta), \\cdots, f_T(\\theta) $表示随机函数在随后的时间步骤$1，\\cdots，T$的实现。随机性可能来自于对数据点的随机子样本（小批量）的评估，也可能来自固有的函数噪声。用$g_t=\\bigtriangledown_{\\theta}f_t(\\theta)$表示梯度，即在时间步长t处计算的$f_t，w.r.t\\;\\theta$的偏导数向量。 ​ 该算法更新梯度$m_t$和平方梯度$v_t$的指数移动平均，其中超参数$β_1，β_2\\in[0，1）$控制这些移动平均的指数衰减率。移动平均值本身就是梯度的第一个矩（平均值）和第二个原始矩（无中心方差）的估计值。然而，这些移动平均值被初始化为（向量）0，导致矩估计值偏向于零，特别是在初始时间步长期间，尤其是当衰减率很小（即$\\beta_s$接近1）时。好消息是，这种初始化偏差可以很容易地抵消，从而得到偏差校正的估计值$\\hat m_t$和$\\hat v_t$。有关更多详细信息，请参阅第3节。 ​ 注意，算法1的效率可以通过改变计算顺序（例如，用下面的行替换循环中的最后三行）来提高算法1的效率: \\alpha_t=\\frac {\\alpha \\cdot \\sqrt{1-\\beta^t_2}}{(1-\\beta^t_1)} \\theta_t = \\theta_{t-1}-\\frac{\\alpha_t\\cdot m_t}{(\\sqrt{v_t}+\\hat \\epsilon )}2.1 Adam更新率​ Adam更新规则的一个重要属性是它对步长的谨慎选择。假设$\\epsilon =0$，时间步长t在参数空间中采取的有效步骤为$\\Delta_t=\\alpha\\cdot \\frac{\\hat m_t}{\\sqrt{\\hat v_t}}. $ 有效步长有两个上界：在$(1-\\beta_1)&gt;\\sqrt{1-\\beta_2}$的情况下$\\left|\\Delta_{t}\\right| \\leq \\alpha \\cdot\\left(1-\\beta_{1}\\right) / \\sqrt{1-\\beta_{2}} $,以及$\\left|\\Delta_{t}\\right| \\leq \\alpha$。否则,第一种情况只发生在最严重的稀疏情况下：梯度在除当前时间步以外的所有时间步上都为零。对于较少稀疏的情况，有效步长将更小。当$\\left(1-\\beta_{1}\\right)=\\sqrt{1-\\beta_{2}}$情况下，有$\\left|\\hat{m}_{t} / \\sqrt{\\hat{v}_{t}}\\right|&lt;1$因此$\\left|\\Delta_{t}\\right|&lt;\\alpha$。在更普通的场景中，因为$|\\mathbb{E}[g] / \\sqrt{\\mathbb{E}\\left[g^{2}\\right]}| \\leq 1$我们有$\\widehat{m}_{t} / \\sqrt{\\widehat{v}_{t}} \\approx \\pm 1$ .每个时间步在参数空间中所采取的有效步长近似为步长设置α的范围，即$\\left|\\Delta_{t}\\right| \\leqq \\alpha$。这可以理解为在当前参数值周围建立一个信任区域，超过该区域，当前梯度估计无法提供足够的信息。这通常使得提前知道α的正确刻度相对容易。例如，对于许多机器学习模型，我们通常预先知道好的最优解在参数空间的某个集合区域内具有高概率；例如，对参数具有先验分布的情况并不少见。由于α在参数空间中设置了步长（的上界），我们通常可以推导出α的正确量级，从而在一定的迭代次数内从$\\theta_0$到达最优值。稍加滥用术语，我们将比率$\\hat{m}_{t} / \\sqrt{\\widehat{v}_{t}}$称为信噪比$（SNR）$。信噪比越小，有效步长$∆t$将更接近于零。这是一个理想的特性，因为较小的信噪比意味着$\\hat m_t$的方向是否与真实梯度的方向相对应存在更大的不确定性。例如，$SNR$值通常会向最优值靠拢，从而导致参数空间中的有效步长更小：这是自动退火的一种形式。有效步长$∆t$也与梯度的比例不变性；用系数c重新缩放梯度g将用系数c缩放$\\hat{m}_{t}$，用系数$c^2$缩放$\\hat{v}_{t}$这抵消了$\\hat{m}_{t} / \\sqrt{\\widehat{v}_{t}}\\left(c \\cdot \\hat{m}_{t}\\right) /(\\sqrt{c^{2} \\cdot \\hat{v}_{t}})=\\hat{m}_{t} / \\sqrt{\\hat{v}_{t}}$。 第三部分：初始化偏差校正​ 如第2节所述，Adam使用初始化偏差校正项。我们将在这里导出二阶矩估计的项；一阶矩估计的推导完全类似。设g是随机目标f的梯度，我们希望用平方梯度的指数移动平均估计其第二原始矩（无中心方差），衰减率为$β2$。设$g_1，\\cdots，g_T$为后续时间步的梯度，每个都是从基本梯度分布$g_t∼p(gT)$中提取的。让我们将指数移动平均值初始化为$v_0=0$（零向量）。首先注意指数移动平均值$v_{t}=\\beta_{2} \\cdot v_{t-1}+\\left(1-\\beta_{2}\\right) \\cdot g_{t}^{2}$（其中$g_t^2$表明了元素平方$g_t\\odot g_t$）在时间步长t处的更新可以写成所有先前时间步长的梯度函数： v_{t}=\\left(1-\\beta_{2}\\right) \\sum_{i=1}^{t} \\beta_{2}^{t-i} \\cdot g_{i}^{2} \\tag{1}​ 我们想知道时间步长t处指数移动平均值的期望值$\\mathbb{E}\\left[v_{t}\\right]$是如何与真实的第二时刻$\\mathbb{E}\\left[g_{t}^2\\right]$相关的，因此我们可以纠正两者之间的差异。取等式（1）左右两侧的期望值： \\begin{aligned} \\mathbb{E}\\left[v_{t}\\right] &=\\mathbb{E}\\left[\\left(1-\\beta_{2}\\right) \\sum_{i=1}^{t} \\beta_{2}^{t-i} \\cdot g_{i}^{2}\\right] \\\\ &=\\mathbb{E}\\left[g_{t}^{2}\\right] \\cdot\\left(1-\\beta_{2}\\right) \\sum_{i=1}^{t} \\beta_{2}^{t-i}+\\zeta \\\\ &=\\mathbb{E}\\left[g_{t}^{2}\\right] \\cdot\\left(1-\\beta_{2}^{t}\\right)+\\zeta \\end{aligned}​ 式中：$ζ=0$，如果真实第二力矩$\\mathbb{E}\\left[g_{i}^2\\right]$是静止的；否则，$ζ$可以保持较小，因为指数衰减率$β1$可以（并且应该）被选择为指数移动平均为过去太远的梯度分配小权重。剩下的是项$（1−β_t)$，这是由用零初始化运行平均值引起的。因此，在算法1中，我们用这个项来修正初始化偏差。 ​ 在稀疏梯度的情况下，为了可靠地估计二阶矩，需要通过选择较小的$β2$值对许多梯度进行平均；然而，正是在小$β2$的情况下，缺少初始化偏差校正将导致初始步骤大得多。 第四部分：收敛性分析​ 我们使用（Zinkevich，2003）提出的在线学习框架来分析Adam的收敛性。给定凸代价函数$f_1（θ），f_2（θ），\\cdots，f_T（θ）$的任意未知序列。在每个时刻$t$，我们的目标是预测参数$θ_t$，并在先前未知的代价函数$f_t$上对其进行评估。由于序列的性质是预先未知的，因此我们使用遗憾来评估我们的算法，即在线预测$f_t(θt)$与来自前面所有步骤的可行集$\\mathcal{X}$。具体地说，遗憾是指： R(T)=\\sum_{t=1}^{T}\\left[f_{t}\\left(\\theta_{t}\\right)-f_{t}\\left(\\theta^{*}\\right)\\right] \\tag{5}​ 其中$\\theta^{*}=\\arg \\min _{\\theta \\in \\mathcal{X}} \\sum_{t=1}^{T} f_{t}(\\theta)$。我们证明Adam没有遗憾边界，并在附录中给出了证明。我们的结果与一般凸在线学习问题的已知界相当。我们还使用一些定义来简化我们的符号，其中$g_{t} \\triangleq \\nabla f_{t}\\left(\\theta_{t}\\right)$和$g_{t,i}$作为第i个元素。我们将$g_{1: t, i} \\in \\mathbb{R}^{t}$定义为一个向量，它包含所有迭代过程中梯度的第i维，直到t，$g_{1: t, i}=\\left[g_{1, i}, g_{2, i}, \\cdots, g_{t, i}\\right]$。同样，我们定义$\\gamma \\triangleq \\frac{\\beta_{1}^{2}}{\\sqrt{\\beta_{2}}}$。当学习速率$α_t$以$t-1$的速率衰减时，我们的以下定理成立，并且第一时刻平均系数$β_{1,t}$以$λ$指数衰减，通常接近1，例如$1-10^{-8}$。 定理4.1. 假设函数ft具有有界梯度，$\\left|\\nabla f_{t}(\\theta)\\right|_{2} \\leq G,\\left|\\nabla f_{t}(\\theta)\\right|_{\\infty} \\leqq G_{\\infty}$对于所有的$\\theta \\in R^{d }$并且Adam生成的任何$θt$之间的距离是有界的，$\\left|\\theta_{n}-\\theta_{m}\\right|_{2} \\leq D, \\left|\\theta_{m}-\\theta_{n}\\right|_{\\infty} \\leq D_{\\infty}$对于任何$m, n \\in\\{1, \\ldots, T\\}, \\text { and } \\beta_{1}, \\beta_{2} \\in[0,1)$满足$\\frac{\\beta_{1}^{2}}{\\sqrt{\\beta_{2}}}&lt;1$，让$\\alpha_{t}=\\frac{\\alpha}{\\sqrt{t}}$并且$\\beta_{1, t}=\\beta_{1} \\lambda^{t-1}, \\lambda \\in(0,1)$。Adam对于所有$T≥1$达到以下保证。 R(T) \\leq \\frac{D^{2}}{2 \\alpha\\left(1-\\beta_{1}\\right)} \\sum_{i=1}^{d} \\sqrt{T \\hat{v}_{T, i}}+\\frac{\\alpha\\left(1+\\beta_{1}\\right) G_{\\infty}}{\\left(1-\\beta_{1}\\right) \\sqrt{1-\\beta_{2}}(1-\\gamma)^{2}} \\sum_{i=1}^{d}\\left\\|g_{1: T, i}\\right\\|_{2}+\\sum_{i=1}^{d} \\frac{D_{\\infty}^{2} G_{\\infty} \\sqrt{1-\\beta_{2}}}{2 \\alpha\\left(1-\\beta_{1}\\right)(1-\\lambda)^{2}} 我们的定理4.1表明，当数据特征是稀疏且有界梯度时，求和项可以远小于其上限$\\sum_{i=1}^{d}\\left|g_{1: T, i}\\right|_{2}&lt;&lt;d G_{\\infty} \\sqrt{T}$并且$\\sum_{i=1}^{d} \\sqrt{T \\widehat{v}_{T, i}}&lt;&lt;d G_{\\infty} \\sqrt{T}$,尤其是如果函数和数据特征的类别是第1.2节(Duchi等人，2011）的形式。他们对期望值$\\mathbb{E}\\left[\\sum_{i=1}^{d}\\left|g_{1: T, i}\\right|_{2}\\right]$的结果也适用于Adam。通常，类似于Adam与Adagrad的自适应方法，可以实现$O(\\log d \\sqrt{T})$相比于非自适应方法计算复杂度$O(\\sqrt{d T})$的改进。在我们的理论分析中，将$β_{1,t}$衰减为零是很重要的，也与以前的经验结果相吻合，例如（Sutskever等人，2013年）表明在训练结束时降低动量系数可以提高收敛性。最后，我们可以展示Adam的平均遗憾. 推论4.2.假设函数$f_t$具有有界梯度，$\\left|\\nabla f_{t}(\\theta)\\right|_{2} \\leq G,\\left|\\nabla f_{t}(\\theta)\\right|_{\\infty} \\leq G_{\\infty} \\text { for all } \\theta \\in R^{d}$并且Adam生成的任何$θt$之间的距离是有界的，$\\left|\\theta_{n}-\\theta_{m}\\right|_{2} \\leq D,\\left|\\theta_{m}-\\theta_{n}\\right|_{\\infty} \\leq D_{\\infty}$对任意的$m, n \\in\\{1, \\ldots, T\\}$。Adam达到以下保证，对于所有$T≥1$。 \\frac{R(T)}{T}=O\\left(\\frac{1}{\\sqrt{T}}\\right)利用定理4.1和$\\sum_{i=1}^{d}\\left|g_{1: T, i}\\right|_{2} \\leq d G_{\\infty} \\sqrt{T}$可以得到这个结果。因此，$\\lim _{T \\rightarrow \\infty} \\frac{R(T)}{T}=0$。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Adam, 优化算法","slug":"Adam-优化算法","permalink":"http://cj_song.gitee.io/myblogs/tags/Adam-%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"}]},{"title":"Windows下安装hexo并部署网站","slug":"blog1_安装hexo以及网站的部署","date":"2020-08-04T14:00:00.000Z","updated":"2020-08-05T02:27:01.164Z","comments":true,"path":"2020/08/04/blog1-an-zhuang-hexo-yi-ji-wang-zhan-de-bu-shu/","link":"","permalink":"http://cj_song.gitee.io/myblogs/2020/08/04/blog1-an-zhuang-hexo-yi-ji-wang-zhan-de-bu-shu/","excerpt":"本文主要介绍在Windows操作系统上使用hexo生成个人博客的软件安装及环境配置，同时记录了过程中用到的相关命令。","text":"本文主要介绍在Windows操作系统上使用hexo生成个人博客的软件安装及环境配置，同时记录了过程中用到的相关命令。 一、安装node.jswindows版本的官网链接为：https://nodejs.org/en/ ，安装过程中CustomSetup这一步记得检查Add—to-PATH是否被选上。 安装完成后命令行输入以下命令检查环境是否配好，正常情况下会返回软件版本号。 npm -v 二、安装hexo在Windows的cmd命令行中输入以下命令安装hexo并验证。 npm install -g hexo hexo -v 如果出现以下错误： hexo : 无法加载文件 C:\\Users\\45478\\AppData\\Roaming\\npm\\hexo.ps1，因为在此系统上禁止运行脚本。 可在管理员模式下的powershell中执行以下命令，输入y回车，之后问题解决。 set-ExecutionPolicy RemoteSigned 三、生成博客步骤为创建工作目录，工作目录初始化，生成博客，开启本地服务预览网站。指令代码如下。 hexo init hexo generate hexo server 四、部署网站 首先执行以下命令安装hexo-deployer-git。 npm install hexo-deployer-git --save 网站的部署可以参考hexo的官方教程，主要用到的命令如下。 hexo deploy deploy之前需要更改_config.yml中deploy段的参数，可使用多个deployer。 deploy: - type: git repo: - type: heroku repo: 修改配置。 deploy: type: git repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: [branch] message: [message] 生成站点文件并推送至远程库。执行以下指令hexo clean hexo deploy 五、HEXO主题可以在官网的主题页面找适合自己的主题，本文所用的主题为volantis，在此对主题的作者表示崇高的敬意！！! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"hexo, 部署网站","slug":"hexo-部署网站","permalink":"http://cj_song.gitee.io/myblogs/tags/hexo-%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-07-22T07:25:31.423Z","updated":"2020-07-11T07:28:00.000Z","comments":true,"path":"2020/07/22/hello-world/","link":"","permalink":"http://cj_song.gitee.io/myblogs/2020/07/22/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"FPGA, ZYNQ, Vitis","slug":"FPGA-ZYNQ-Vitis","permalink":"http://cj_song.gitee.io/myblogs/tags/FPGA-ZYNQ-Vitis/"},{"name":"FPGA, ZYNQ, LUT","slug":"FPGA-ZYNQ-LUT","permalink":"http://cj_song.gitee.io/myblogs/tags/FPGA-ZYNQ-LUT/"},{"name":"Adam, 优化算法","slug":"Adam-优化算法","permalink":"http://cj_song.gitee.io/myblogs/tags/Adam-%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"},{"name":"hexo, 部署网站","slug":"hexo-部署网站","permalink":"http://cj_song.gitee.io/myblogs/tags/hexo-%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99/"}]}