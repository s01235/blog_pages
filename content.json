{"meta":{"title":"Jian's Blog","subtitle":"","description":"","author":"SongChenjian","url":"http://cj_song.gitee.io/myblogs","root":"/myblogs/"},"pages":[{"title":"404 Not Found","date":"2020-08-13T10:47:36.295Z","updated":"2020-08-06T08:02:32.253Z","comments":true,"path":"404.html","permalink":"http://cj_song.gitee.io/myblogs/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"关于","date":"2020-08-13T10:53:15.655Z","updated":"2020-08-13T10:53:08.083Z","comments":true,"path":"about/index.html","permalink":"http://cj_song.gitee.io/myblogs/about/index.html","excerpt":"","text":"name宋晨健 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"所有分类","date":"2020-08-13T10:53:15.658Z","updated":"2020-08-13T10:52:37.004Z","comments":true,"path":"categories/index.html","permalink":"http://cj_song.gitee.io/myblogs/categories/index.html","excerpt":"","text":"test document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-08-06T07:20:00.000Z","updated":"2020-08-06T07:24:08.792Z","comments":true,"path":"contact/index.html","permalink":"http://cj_song.gitee.io/myblogs/contact/index.html","excerpt":"","text":"test document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2020-08-13T10:47:36.321Z","updated":"2020-07-11T06:22:21.000Z","comments":true,"path":"mylist/index.html","permalink":"http://cj_song.gitee.io/myblogs/mylist/index.html","excerpt":"","text":"test document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"我的朋友们","date":"2020-08-13T11:11:51.428Z","updated":"2020-08-13T11:11:15.953Z","comments":true,"path":"friends/index.html","permalink":"http://cj_song.gitee.io/myblogs/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"所有标签","date":"2020-08-13T11:12:27.147Z","updated":"2020-08-13T11:11:33.182Z","comments":true,"path":"tags/index.html","permalink":"http://cj_song.gitee.io/myblogs/tags/index.html","excerpt":"","text":"test document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"Webots盾构仿真基本操作","slug":"blog8_Webots盾构仿真基本操作","date":"2021-03-18T09:00:00.000Z","updated":"2021-03-18T08:04:54.418Z","comments":true,"path":"2021/03/18/blog8-webots-dun-gou-fang-zhen-ji-ben-cao-zuo/","link":"","permalink":"http://cj_song.gitee.io/myblogs/2021/03/18/blog8-webots-dun-gou-fang-zhen-ji-ben-cao-zuo/","excerpt":"","text":"一、文件目录结构盾构仿真工程中的相关文件目录如下： 其中， Controllers里面存放了各个机构对应的控制器程序。 docs存放了该工程中记录的一些文档以及参考的一些资料。 protos文件夹存放了protos文件（通过机器人的urdf文件导出生成）。 wbo文件夹存放从webots里面导出的节点文件，如管片节点，轴线显示点的节点等等。 webots_world为webots仿真场景文件，里面包含所有的机器人，环境等实际对象。 wrl里面存放了从3D建模软件中导出的一些3D模型文件，其文件类型有stl，wrl等; 二、Webots环境简介Webots是一个基于ODE（开源物理引擎）所开发的一款开源机器人仿真环境，通过此软件，可以实现自主设计机器人的虚拟仿真，验证算法等，其能够较为真实的模拟真实世界的重力，摩擦力，光线，流体等物理对象，同时也提供了非常多的演示例子，包括针对于每个传感器，每种接口的基础例子，以及针对自动驾驶等大型城市，村庄场景演示。除此之外，此平台提供了非常便利的编程语言接口，可以通过控制器程序实现对机器人本身的基础控制，也可通过主管控制器接口来在程序中对场景中任意节点的任意属性执行更改，除此之外，用户还可以通过编写物理插件来实现更符合自己需求的功能。 2.1、盾构仿真场景主界面 可以在3D视图窗口点击鼠标右键，选择添加节点，像场景添加可视对象或相关属性节点。 2.2、盾构仿真需要用到基本程序接口 直线电机旋转电机（油缸、刀盘驱动）的位置，速度，力矩控制等。 主管控制器接口动态的向场景添加管片，标签，或是虚拟的标识线，标示物体等。 使用matlab仿真过程可以在控制器的头部添加如下代码，实现代码的调试。 desktop; keyboard; 2.3、盾构控制器程序设计stm_controller ：实现主函数，完成沿轴线自主推进。 |———CylinderController: 此类为油缸分组控制器类，可以通过此类实现油缸的分组控制。 |———SupervisorController:主控控制器类，在此类中实现对场景的基本操作，如向其中添加节点，设置节点的属性（更改节点的位置等）等。 |———DTADesign: 隧道期望中心轴线类，在此类中可实现纠偏路径、期望轴线的设计、期望轴线的可视化显示等等功能。 后面可逐步扩展类，及类里面的成员函数。 2.4、运行此世界可能遇到的问题 某些节点调用的资源文件在更换电脑后其路径会发生改变，要注意命令行窗口的报错信息，更改对应资源文件的路径设置。 Matlab缺少相应的软件功能包，可在matlab附加功能里面搜索对应的软件包名称，登录账号安装即可。 2.5、下一步仿真路线 设计期望的推进轴线。 控制每组油缸推进长度，刀盘的旋转速度，实现对盾构位姿的控制。 在前两步基础上，让盾构延期望轴线精确推进。 更新环境模拟机构，使其能更为合理的模拟土体作用。 在对应的机构上部署推导出的数学模型以及控制率，实现更接近真实的仿真。 可视化显示推进参数等。 2.6、小技巧 需要向场景添加模型文件，可以从solidworks导出vrml97类型文件，然后导入到webots中，注意设置webots里面边界对象，否则检测不到碰撞，会出现穿模的情况。 可视化轴线可以采用主管控制器接口，向其中添加多个轴线点节点来实现，也可以参考supervisor_draw_trail.wbt例程，可视化轴线。 可视化接触力大小可借鉴技巧2中的实现方法。 三、Webots参考文档用户指南：https://cyberbotics.com/doc/guide/index参考手册：https://cyberbotics.com/doc/reference/index document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"盾构，webots","slug":"盾构，webots","permalink":"http://cj_song.gitee.io/myblogs/tags/%E7%9B%BE%E6%9E%84%EF%BC%8Cwebots/"}]},{"title":"单液压缸仿真","slug":"blog7_单液压缸仿真","date":"2020-11-06T09:00:00.000Z","updated":"2020-11-08T08:55:05.203Z","comments":true,"path":"2020/11/06/blog7-dan-ye-ya-gang-fang-zhen/","link":"","permalink":"http://cj_song.gitee.io/myblogs/2020/11/06/blog7-dan-ye-ya-gang-fang-zhen/","excerpt":"本文参考网址：https://www.mathworks.com/help/simulink/slref/single-hydraulic-cylinder-simulation.html","text":"本文参考网址：https://www.mathworks.com/help/simulink/slref/single-hydraulic-cylinder-simulation.html 一、模型的分析与物理描述图1展示了该系统的原理结构，此模型中油泵流量$Q$在控制阀处提供压力$p_1$，$C_2$为溢流阀，其流量被定义为$q_{1ex}$，活塞/缸体组件的控制阀建模为对可变直径管道的液体流的控制，液体流$q_{12}$，引起了液体压力$p_2$，它在将其连接到执行器气缸的管路中承受随后的压降。液缸压力$p_3$，推动弹性负载的移动并产生位移量$x$。 在泵的输出端，流量被分流到溢流阀和控制阀两部分，我们将溢出流量$q_{1ex}$建模为层流，如下： \\begin{array}{l} Q=q_{12}+q_{1 e x} \\\\ q_{1 e x}=C_{2} \\cdot p_{1} \\\\ p_{1}=\\frac{\\left(Q-q_{12}\\right)}{C_{2}} \\\\ Q=\\text { pump flow } \\\\ q_{12}=\\text { control valve flow } \\\\ q_{1 e x}=\\text { leakage } \\\\ C_{2}=\\text { flow coefficient } \\\\ p_{1}=\\text { pump pressure } \\end{array}我们用节流孔方程对通过控制阀的液流进行了建模。符号和绝对值函数可适应任一方向的流量，如下： \\begin{array}{l} q_{12}=C_{d} \\cdot A \\cdot \\operatorname{sgn}\\left(p_{1}-p_{2}\\right) \\cdot \\sqrt{\\frac{2}{\\rho}\\left|p_{1}-p_{2}\\right|} \\\\ C_{d}=\\text { orifice discharge coefficient，孔流系数。 } \\\\ A=\\text { orifice area 孔面积。} \\\\ p_{2}=\\text { pressure downstream of control valve，控制阀下游的压力。 } \\\\ \\rho=\\text { fluid density } \\end{array}气缸内的流体由于该流量而增压，$q_{12} = q_{23}$，减去活塞运动的顺应性。在这种情况下，我们还对流体的可压缩性进行了建模。 \\begin{array}{l} \\frac{d p_{3}}{d t}=\\frac{\\beta}{V_{3}}\\left(q_{12}-A_{c} \\frac{d x}{d t}\\right) \\\\ V_{3}=V_{30}+A_{c} \\cdot x \\\\ p_{3}=\\text { piston pressure } \\\\ \\beta=\\text { fluid bulk modulus, 液体弹性模量。} \\\\ V_{3}=\\text { fluid volume at } p_{3} \\\\ V_{30}=\\text { fluid volume in the piston for } x=0 \\\\ A_{c}=\\text { cylinder cross-sectional area，液缸截面积。} \\end{array}由于较大的液压力，我们忽略了活塞和弹簧的质量。我们通过微分这种关系并结合p2和p3之间的压降来完成方程组。 Equation Block 3对从阀到执行器的管路中的层流进行建模。下列方程给出了活塞处的力平衡。 \\begin{array}{l} x=p_{3} \\frac{A_{c}}{K} \\\\ \\frac{d x}{d t}=\\frac{d p_{3}}{d t} \\frac{A_{c}}{K} \\\\ q_{23}=q_{12}=C_{1}\\left(p_{2}-p_{3}\\right) \\\\ p_{2}=p_{3}+\\frac{q_{12}}{C_{1}} \\\\ K=\\text { spring constant } \\\\ C_{1}=\\text { laminar flow coefficient } \\end{array}二、泵子系统右键单击$Pump Masked$子系统，然后选择 Mask &gt; Look Under Mask。泵模型根据泵流量和负载（输出）流量计算供应压力（下图）。 $Qpump$是泵流量数据（保存在模型工作区中）。具有时间点列向量和相应流量$[T，Q]$的矩阵指定流量数据。该模型按公式块1所示计算压力$p_1$。由于$Qout = q_{12}$是$p1$的直接函数（通过控制阀），因此形成了代数环路。估计初始值$p10$可以实现更有效的解决方案。 三、阀门、油缸、活塞，弹簧等组成的子系统微分代数方程组用压力$p_3$来模拟气缸增压，压力在方程式3中作为导数出现，并用作状态（积分器）。如果忽略活塞质量，则弹簧力和活塞位置是$p_3$的直接倍数，而速度是$p_3$的时间导数的直接倍数。后一种关系在$“ Beta”$增益块周围形成代数循环。中间压力$p_2$是$p_3$与由于从阀流向气缸的流量而引起的压降之和（公式框4）。这种关系还通过控制阀和$1/C_1$增益施加了代数约束。 四、仿真结果仿真数据参数设置如下：该信息是从$MAT$文件$sldemo_hydcyl_data.mat$加载的，该文件也用于其他两个液压缸模型。用户可以通过泵和气缸$Mask$输入数据。 \\begin{array}{l} C_{d}=0.61 \\\\ \\rho=800 \\mathrm{kg} / \\mathrm{m}^{3} \\\\ C_{1}=2 e-8 \\mathrm{m}^{3} / \\mathrm{sec} / \\mathrm{Pa} \\\\ C_{2}=3 e-9 \\mathrm{m}^{3} / \\mathrm{sec} / \\mathrm{Pa} \\\\ \\beta=7 e 8 \\mathrm{Pa} \\\\ A_{c}=1 e-3 \\mathrm{m}^{2} \\\\ K=5 e 4 \\mathrm{N} / \\mathrm{m} \\\\ V_{30}=2.5 e-5 \\mathrm{m}^{3}\\\\ \\begin{array}{l} T=\\left[\\begin{array}{llllll} 0 & 0.04 & 0.04 & 0.05 & 0.05 & 0.1 \\end{array}\\right] \\text { sec } \\\\ Q=\\left[\\begin{array}{lllll} 0.005 & 0.005 & 0 & 0 & 0.005 & 0.005 \\end{array}\\right] \\mathrm{m}^{\\wedge} 3 / \\mathrm{sec} \\end{array} \\end{array}仿真结果图：系统最初逐步达到$0.005\\; \\mathrm{m}^{\\wedge} 3 / \\mathrm{sec}=300 \\;\\mathrm{l} / \\mathrm{min}$的泵流量,在$t=0.04s$时流速突然下降到$0$，然后在$t = 0.05$秒时恢复其初始流速。 控制阀在$0.1s$的仿真时间内，从$0$初始面积逐步增到$1e-4 \\; sq.m$。随着阀门的关闭，所有的流量都从溢流阀泄露，初始的泵压力增加到$p_{10}=Q/C_2=1667kPa$。 如图7所示，当阀打开时，压力$p_2$和$p_3$增大，而$p_1$则根据负载的增加而减小，当泵流量切断时，弹簧和活塞就像一个蓄能器，而$p_3$则连续减小。然后，流体反向流动，因此尽管$p_2$相对接近$p_3$，却突然下降。在泵本身，所有的回流泄漏和$p_1$都急剧下降。还原续流后，行为会相反。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"液压缸，matlab","slug":"液压缸，matlab","permalink":"http://cj_song.gitee.io/myblogs/tags/%E6%B6%B2%E5%8E%8B%E7%BC%B8%EF%BC%8Cmatlab/"}]},{"title":"使用粒子过滤器跟踪类车机器人","slug":"blog6_使用粒子过滤器跟踪类车机器人","date":"2020-11-06T09:00:00.000Z","updated":"2021-03-17T08:50:35.292Z","comments":true,"path":"2020/11/06/blog6-shi-yong-li-zi-guo-lu-qi-gen-zong-lei-che-ji-qi-ren/","link":"","permalink":"http://cj_song.gitee.io/myblogs/2020/11/06/blog6-shi-yong-li-zi-guo-lu-qi-gen-zong-lei-che-ji-qi-ren/","excerpt":"本例参考网址：https://ww2.mathworks.cn/help/robotics/ug/track-a-car-like-robot-using-particle-filter.html","text":"本例参考网址：https://ww2.mathworks.cn/help/robotics/ug/track-a-car-like-robot-using-particle-filter.html粒子滤波器是一种基于采样的递归贝叶斯估计算法，该算法在stateEstimatorPF对象中实现。在本例中，户外环境下一个类车机器人将被跟踪，机器人位置的测量通过板载的带有噪声的GPS来实现。将已知的运动命令发送给机器人，由于固有的延迟以及模型的不准确性，机器人并不会执行确切的运动指令。本文示例将说明如何使用stateEstimatorPF对象来减少测量数据中的噪声影响，并获得对机器人位置的更准确的估计。汽车类机器人的运动学模型由以下非线性系统描述。粒子滤波器非常适合估计此类系统的状态，因为它可以处理固有的非线性。 \\dot{x}=vcos(\\theta)\\\\ \\dot{y}=vsin(\\theta)\\\\ \\dot{\\theta}=\\frac{v}{L}tan\\phi\\\\ \\dot{\\phi}=\\omega一、场景描述类似于汽车的机器人不断驱动并改变其速度和转向角。机器人的位置的测量是由一些嘈杂的外部系统（例如GPS或Vicon系统）来实现的。沿着这条路径，它将穿过无法进行测量的室内区域。 输入： 机器人局部位置的噪声测量值$(x,y,\\theta)$。注意这不是全状态的测量，前轮的方向$\\phi$以及$(\\dot{x},\\dot{y},\\dot{\\theta},\\dot{\\phi})$是没有测量的。 线速度及角速度指令$v_{C^{‘}},\\omega_C$被发送给机器人。注意机器人的指令运动与实际运动之间会有一些差异。 目标：估计类车机器人的局部位置$(x,y,\\theta)$。注意车轮方向不包含在估计中，从观测器的角度看，车的全状态为$[x,y,\\theta,\\dot{x},\\dot{y},\\dot{\\theta}]$ 。 方法：使用stateEstimatorPF函数处理两个带有噪声的输入（两个输入本身都不可靠），并对当前部分位置进行最优估计。 在预测阶段，我们使用简化的，类似于独轮车的机器人模型更新粒子的状态，如下所示。请注意，用于状态估计的系统模型不是实际系统的精确表示。只要可以很好地捕获系统噪声（以粒子群表示）中的模型差异，这是可以接受的。有关更多详细信息，请参见 predict。 \\dot{x}=vcos(\\theta)\\\\ \\dot{y}=vsin(\\theta)\\\\ \\dot{\\theta}=\\omega 在修正阶段，粒子的重要权值（似然性）由当前测量的误差范数确定$(\\sqrt{(\\Delta x)^2+(\\Delta y)^2+(\\Delta \\theta)^2})$，因为我们仅对这三个变量进行测量，更多详细信息参见 correct. 二、初始化类车机器人rng('default'); % for repeatable result dt = 0.05; % time step initialPose = [0 0 0 0]'; carbot = ExampleHelperCarBot(initialPose, dt); 三、设置粒子滤波器本部分使用5000个粒子配置粒子过滤器。最初，所有粒子都是从正态分布中随机选取的，其初始状态和单位协方差为均值。每个粒子包含6个状态变量$(x,y,\\theta,\\dot{x},\\dot{y},\\dot{\\theta})$。注意，第三个变量标记为圆形，因为它是汽车的方向。指定两个回调函数$StateTransitionFcn$和$MeasurementLikelihoodFcn$也非常重要。这两个函数直接决定了粒子过滤器的性能。这两个函数的详细信息可以在本示例的最后两个部分中找到。 pf = stateEstimatorPF; initialize(pf, 5000, [initialPose(1:3)', 0, 0, 0], eye(6), 'CircularVariables',[0 0 1 0 0 0]); pf.StateEstimationMethod = 'mean'; pf.ResamplingMethod = 'systematic'; % StateTransitionFcn defines how particles evolve without measurement pf.StateTransitionFcn = @exampleHelperCarBotStateTransition; % MeasurementLikelihoodFcn defines how measurement affect the our estimation pf.MeasurementLikelihoodFcn = @exampleHelperCarBotMeasurementLikelihood; % Last best estimation for x, y and theta lastBestGuess = [0 0 0]; 四、主循环注意，在此示例中，命令给机器人的线性和角速度是随时间变化的任意函数。另外，注意循环的固定速率计时是通过 rateControl实现的。 使用固定速率支持以20 Hz的频率运行20秒。 r = rateControl(1/dt); 重置固定速率对象以重新启动计时器。在运行与时间有关的代码之前，请立即重置计时器。 reset(r); simulationTime = 0; while simulationTime < 20 % if time is not up % Generate motion command that is to be sent to the robot % NOTE there will be some discrepancy between the commanded motion and the % motion actually executed by the robot. uCmd(1) = 0.7*abs(sin(simulationTime)) + 0.1; % linear velocity uCmd(2) = 0.08*cos(simulationTime); % angular velocity drive(carbot, uCmd); % Predict the carbot pose based on the motion model [statePred, covPred] = predict(pf, dt, uCmd); % Get GPS reading measurement = exampleHelperCarBotGetGPSReading(carbot); % If measurement is available, then call correct, otherwise just use % predicted result if ~isempty(measurement) [stateCorrected, covCorrected] = correct(pf, measurement'); else stateCorrected = statePred; covCorrected = covPred; end lastBestGuess = stateCorrected(1:3); % Update plot if ~isempty(get(groot,'CurrentFigure')) % if figure is not prematurely killed updatePlot(carbot, pf, lastBestGuess, simulationTime); else break end waitfor(r); % Update simulation time simulationTime = simulationTime + dt; end 五、结果图说明这三个图显示了粒子滤波器的跟踪性能。 在第一个图中，粒子过滤器在偏离初始姿势的情况下很好地跟踪了汽车。 在第二幅图中，机器人驶入无法进行测量的屋顶区域，并且粒子仅基于预测模型（标有橙色）而演化。您可以看到粒子逐渐形成马蹄形的前部，并且估计的姿势逐渐偏离实际的姿势。 在第三张图中，机器人已驶出屋顶区域。通过新的测量，估计的姿势逐渐收敛到实际姿势。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"机器人，matlab","slug":"机器人，matlab","permalink":"http://cj_song.gitee.io/myblogs/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA%EF%BC%8Cmatlab/"}]},{"title":"ROS2常用指令","slug":"blog5_ROS2常用指令","date":"2020-10-25T09:00:00.000Z","updated":"2020-10-25T01:56:17.077Z","comments":true,"path":"2020/10/25/blog5-ros2-chang-yong-zhi-ling/","link":"","permalink":"http://cj_song.gitee.io/myblogs/2020/10/25/blog5-ros2-chang-yong-zhi-ling/","excerpt":"本文记录ROS2常用的命令行操作指令。包括话题，服务，参数，动作等命令行命令。本文参考博客链接为：https://www.guyuehome.com/category/column/ros2-tutorials。","text":"本文记录ROS2常用的命令行操作指令。包括话题，服务，参数，动作等命令行命令。本文参考博客链接为：https://www.guyuehome.com/category/column/ros2-tutorials。 一、安装调试过程 将指令写入环境变量： echo \"source /opt/ros/foxy/setup.bash\" >> ~/.bashrc 查看环境变量是否写入成功： printenv | grep -i ROS 设置ROS组网ID: export ROS_DOMAIN_ID= echo \"export ROS_DOMAIN_ID=\" >> ~/.bashrc 安装海龟仿真器： sudo apt update sudo apt install ros-foxy-turtlesim 检查功能包是否安装成功： ros2 pkg executables turtlesim 启动海龟仿真器节点： ros2 run turtlesim turtlesim_node 查看节点，话题，服务，动作： ros2 node list ros2 topic list ros2 service list ros2 action list 安装rqt工具： sudo apt update sudo apt install ~nros-foxy-rqt* 通过remapping 给节点重命名： ros2 run turtlesim turtle_teleop_key --ros-args --remap turtle1/cmd_vel:=turtle2/cmd_vel 二、节点相关指令 启动节点程序： ros2 run ros2 run turtlesim turtlesim_node 列出节点： ros2 node list 重映射： ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle 查看节点信息： ros2 node info ros2 node info /my_turtle 三、话题相关指令 列出所有话题： ros2 topic list ros2 topic list -t #显示消息数据类型 返回话题数据： ros2 topic echo ros2 topic echo /turtle1/cmd_vel 显示话题信息： ros2 topic info /turtle1/cmd_vel 查看话题中消息的具体数据结构： ros2 interface show geometry_msgs/msg/Twist 发布话题消息： ros2 topic pub '' #这里的 ‘’就是具体的消息内容啦，我们需要使用YAML的语法来描述，比如要发布速度指令Twist: #–once表示这个消息只发布一次就退出。 ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 2.0, z: 2.0}, angular: {x: 0, y: 0, z: 2.0}}\" #持续发布 #–rate参数就表示频率啦，单位是hz ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\" 查看话题消息的发布频率： ros2 topic hz /turtle1/pose 四、服务相关指令 列出服务： ros2 service list ros2 service list -t 查看服务的数据结构： ros2 service type 查找提供某类型数据的所有服务: ros2 service find ros2 service find std_srvs/srv/Empty 查看服务数据类型的具体结构: ros2 interface show .srv ros2 interface show std_srvs/srv/Empty.srv 通过终端发送服务请求： ros2 service call ros2 service call /clear std_srvs/srv/Empty ros2 service call /spawn turtlesim/srv/Spawn \"{x: 2, y: 2, theta: 0.2, name: ''}\" 五、参数服务相关指令 查看参数列表： ros2 param list 获取参数值： ros2 param get &lt;node_name&gt; &lt;parameter_name&gt; ros2 param get /turtlesim background_g 设置参数值： ros2 param set ros2 param set /turtlesim background_r 150 保存参数： ros2 param dump ros2 param dump /turtlesim 加载参数文件： ros2 run --ros-args --params-file ros2 run turtlesim turtlesim_node --ros-args --params-file ./turtlesim.yaml 六、Action相关指令 查看action列表： ros2 action list ros2 action list -t 查看action信息： ros2 action info /turtle1/rotate_absolute 查看action数据类型： ros2 interface show turtlesim/action/RotateAbsolute.action 命令行发送action目标： ros2 action send_goal #同样是YAML格式描述的数据。发送一个试试： ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: 1.57}\" #如果先要看到action中的周期反馈，以上命令还需要加一个–feedback参数： ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: -1.57}\" --feedback document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"ROS2, Bash。","slug":"ROS2-Bash。","permalink":"http://cj_song.gitee.io/myblogs/tags/ROS2-Bash%E3%80%82/"}]},{"title":"使用ZYNQ实现单LUT内容的动态修改（二）PS端动态修改LUT内容，软件部分，Vitis操作","slug":"blog4_LUT内容读取2","date":"2020-10-23T08:00:00.000Z","updated":"2020-10-23T08:42:46.742Z","comments":true,"path":"2020/10/23/blog4-lut-nei-rong-du-qu-2/","link":"","permalink":"http://cj_song.gitee.io/myblogs/2020/10/23/blog4-lut-nei-rong-du-qu-2/","excerpt":"该系统的软件部分使用Xilinx Vitis平台进行实现，操作方法类似于之前版本的SDK，不同的是Vitis中的硬件平台要自己手动导入，其余编译调试大体相同。","text":"该系统的软件部分使用Xilinx Vitis平台进行实现，操作方法类似于之前版本的SDK，不同的是Vitis中的硬件平台要自己手动导入，其余编译调试大体相同。 一，摘要该篇博客主要记录软件端的整个流程，主要依据官方给出的HW_ICAP驱动库进行开发。具体硬件原理方面的知识不做太多介绍。有需要的话可以参考官方的一些手册。 二，程序流程程序循环执行以下四种操作， 输入FAR寄存器值，读取对应地址的数据帧。 输入要修改的LUT的位置，该位置可通过生成硬件时的Layout找出。 输入要修改LUT的新数据。将修改过的数据帧写入FPGA内部。 重新读出数据帧，与写入的数据帧进行对比，完全一致即返回修改成功，返回操作1。三，工程的建立与调试主要记录一些关键步骤！第一步，导入上篇博客生成的硬件平台导入上篇博客工程目录下的xsa文件。接下来编译该硬件平台。第二步，导入并编译修改单LUT的程序导入.\\src\\vitis\\目录下的C语言源文件，如下图所示。 接下来需要注意官方的驱动有个BUG，针对于ZYNQ系列的器件，其DeviceIDCode并没有在7系列里面包含，这就使得在执行XHwIcap_CfgInitialize（）函数时出错，所以在此处要将其ID号改成7系列列表中有的ID号，如下图239行所示。 第三步，调试工程。右击工程选择Debug As/DebugConfiguration,然后设置如下图，点击调试。此时我们把top2.bit文件下载到FPGA部分，可以看到其LUT的输出内容如下图，通过串口助手输入FAR地址字段，对FPGA内部该地址的配置帧进行读取。截取部分读出的配置数据如下图所示，可在转换过后的rbt文件中找到该配置帧的数据。我们需要操作的目标LUT的前1/4配置数据为下图中0x55550000这一数据，我们此时要对其进行更改。首先我们要输入该LUT数据在该帧数据中的位置08（此位置可以通过layout看出来）。进一步输入要修改成的数据，如下图所示，正常情况下返回Success即为写入成功。最终我们再来看一下该LUT输出的波形如下，可以看出其内部数据已经被修改了。 四、中间遇到的问题 读帧数据时显示不完整，后小部分出现0xfffffffd,此种情况是由于AXI_ICAP ip的读FIFO容量设置太小造成的，中间会有部分数据缺失。解决办法，调大读FIFO的容量。 写帧数据时写不进去，经排查发现为设置正确的DeviceID号，改正后问题解决。 配置数据与LUT实际存储内容的映射关系还没来得及整清楚，看后面是否用得到。五、总结基本打通了单LUT读写的底层通路，为后面重构控制器的设计打下了基础。考虑通过云端等接口实现远程LUT内容的读写等操作，基于此可实现FPGA内部错误的自修复，高效重构任务的执行等高级功能。六、附程序代码如下 #include #include #include #include \"xparameters.h\" #include \"xil_printf.h\" #include \"xil_cache.h\" #include \"ff.h\" #include \"xdevcfg.h\" #include \"xhwicap.h\" #include \"xil_io.h\" #include \"xil_types.h\" #define PYNQ #define FRAME_WORDS_NUM 202 // Parameters for Partial Reconfiguration #ifdef PYNQ #define READ_FRAME_SIZE 30 #define WRITE_FRAME_SIZE 91 #define PARTIAL_MULT_ADDR 0x200000 #define PARTIAL_ADDER_ADDR 0x300000 #define PARTIAL_BLANK_ADDR 0x400000 #define PARTIAL_MULT_BITFILE_LEN 0xC66F // in number of words #define PARTIAL_ADDER_BITFILE_LEN 0xC66F // in number of words #define PARTIAL_BLANK_BITFILE_LEN 0xC66F // in number of words #endif // Turn on/off Debug messages #ifdef DEBUG_PRINT #define debug_printf xil_printf #else #define debug_printf(msg, args...) do { } while (0) #endif // Read function for STDIN extern char inbyte(void); // Driver Instantiations static XDcfg_Config *XDcfg_0; XDcfg DcfgInstance; XDcfg *DcfgInstPtr; static XHwIcap HwIcap; // The instance of the HWICAP device XHwIcap *HwIcapInstPtr; uint32_t read_FrameBuffer[FRAME_WORDS_NUM]; uint32_t read_FrameBuffer_verify[FRAME_WORDS_NUM]; unsigned char uartBuffer[16]; uint32_t addr_word; //FAR Word. uint32_t new_word; //The word to be writen to lut; uint32_t lut_index; // int XHwIcap_DeviceReadFrame1(XHwIcap *InstancePtr, uint32_t far_word , u32 *FrameBuffer) { u32 Packet; u32 Data; u32 TotalWords; int Status; u32 WriteBuffer[WRITE_FRAME_SIZE]; u32 Index = 0; u32 NumNoops; Xil_AssertNonvoid(InstancePtr != NULL); Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY); Xil_AssertNonvoid(FrameBuffer != NULL); /* * DUMMY and SYNC */ WriteBuffer[Index++] = XHI_DUMMY_PACKET; WriteBuffer[Index++] = XHI_BUS_WTH_PACKET; WriteBuffer[Index++] = XHI_BUS_DET_PACKET; WriteBuffer[Index++] = XHI_DUMMY_PACKET; WriteBuffer[Index++] = XHI_SYNC_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; /* * Reset CRC */ Packet = XHwIcap_Type1Write(XHI_CMD) | 1; WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = XHI_CMD_RCRC; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; /* * Setup CMD register to read configuration */ Packet = XHwIcap_Type1Write(XHI_CMD) | 1; WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = XHI_CMD_RCFG; WriteBuffer[Index++] = XHI_NOOP_PACKET; /* * Setup FAR register. */ Packet = XHwIcap_Type1Write(XHI_FAR) | 1; Data = far_word; WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = Data; /* * Setup read data packet header. * The frame will be preceeded by a dummy frame, and we need to read one * extra word for V4 and V5 devices. */ switch (InstancePtr->DeviceFamily) { case DEVICE_TYPE_7SERIES : TotalWords = InstancePtr->WordsPerFrame < 1; NumNoops = 32; break; case DEVICE_TYPE_ULTRA : TotalWords = (InstancePtr->WordsPerFrame < 1) + 10; NumNoops = 64; break; case DEVICE_TYPE_ULTRA_PLUS : TotalWords = (InstancePtr->WordsPerFrame < 1) + 25; NumNoops = 64; break; default: return XST_FAILURE; } /* * Create Type one packet */ Packet = XHwIcap_Type1Read(XHI_FDRO); WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = 0x48000000 | TotalWords; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; for(unsigned int i = 0; i < NumNoops; i++) { WriteBuffer[Index++] = XHI_NOOP_PACKET; } /* * Write the data to the FIFO and initiate the transfer of data * present in the FIFO to the ICAP device */ Status = XHwIcap_DeviceWrite(InstancePtr, (u32 *)&WriteBuffer[0], Index); if (Status != XST_SUCCESS) { return XST_FAILURE; } /* * Wait till the write is done. */ while (XHwIcap_IsDeviceBusy(InstancePtr) != FALSE); /* * Read the frame of the data including the NULL frame. */ Status = XHwIcap_DeviceRead(InstancePtr, FrameBuffer, TotalWords); if (Status != XST_SUCCESS) { return XST_FAILURE; } /* * Send DESYNC command */ Status = XHwIcap_CommandDesync(InstancePtr); if (Status != XST_SUCCESS) { return XST_FAILURE; } return XST_SUCCESS; }; int XHwIcap_DeviceWriteFrame1(XHwIcap *InstancePtr, u32 far_word, u32 *FrameData) { u32 Packet; u32 Data; u32 TotalWords; int Status; u32 WriteBuffer[READ_FRAME_SIZE]; u32 Index =0; Xil_AssertNonvoid(InstancePtr != NULL); Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY); Xil_AssertNonvoid(FrameData != NULL); /* * DUMMY and SYNC */ WriteBuffer[Index++] = XHI_DUMMY_PACKET; WriteBuffer[Index++] = XHI_SYNC_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; /* * Reset CRC */ Packet = XHwIcap_Type1Write(XHI_CMD) | 1; Data = XHI_CMD_RCRC; WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = Data; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; /* * Bypass CRC */ /* * ID register */ Packet = XHwIcap_Type1Write(XHI_IDCODE) | 1; Data = InstancePtr->DeviceIdCode; WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = Data; /* * Setup FAR */ Packet = XHwIcap_Type1Write(XHI_FAR) | 1; Data = far_word; WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = Data; /* * Setup CMD register - write configuration */ Packet = XHwIcap_Type1Write(XHI_CMD) | 1; Data = XHI_CMD_WCFG; WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = Data; WriteBuffer[Index++] = XHI_NOOP_PACKET; /* * Setup Packet header. */ TotalWords = InstancePtr->WordsPerFrame < 1; if (TotalWords < XHI_TYPE_1_PACKET_MAX_WORDS) { /* * Create Type 1 Packet. */ Packet = XHwIcap_Type1Write(XHI_FDRI) | TotalWords; WriteBuffer[Index++] = Packet; } else { /* * Create Type 2 Packet. */ Packet = XHwIcap_Type1Write(XHI_FDRI); WriteBuffer[Index++] = Packet; Packet = XHI_TYPE_2_WRITE | TotalWords; WriteBuffer[Index++] = Packet; } /* * Write the Header data into the FIFO and intiate the transfer of * data present in the FIFO to the ICAP device */ Status = XHwIcap_DeviceWrite(InstancePtr, (u32 *)&WriteBuffer[0], Index); if (Status != XST_SUCCESS) { return XST_FAILURE; } /* * Write the modified frame data. */ Status = XHwIcap_DeviceWrite(InstancePtr, (u32 *) &FrameData[InstancePtr->WordsPerFrame], InstancePtr->WordsPerFrame); if (Status != XST_SUCCESS) { return XST_FAILURE; } /* * Write out the pad frame. The pad frame was read from the device * before the data frame. */ Status = XHwIcap_DeviceWrite(InstancePtr, (u32 *) &FrameData[0], InstancePtr->WordsPerFrame); if (Status != XST_SUCCESS) { return XST_FAILURE; } /* Add CRC */ Index = 0; Packet = XHwIcap_Type1Write(XHI_CMD) | 1; Data = XHI_CMD_RCRC; WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = Data; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; /* Park the FAR */ Packet = XHwIcap_Type1Write(XHI_FAR) | 1; Data = XHwIcap_SetupFar(0, 0, 3, 33, 0); WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = Data; /* Add CRC */ Packet = XHwIcap_Type1Write(XHI_CMD) | 1; Data = XHI_CMD_RCRC; WriteBuffer[Index++] = Packet; WriteBuffer[Index++] = Data; WriteBuffer[Index++] = XHI_NOOP_PACKET; WriteBuffer[Index++] = XHI_NOOP_PACKET; /* * Intiate the transfer of data present in the FIFO to * the ICAP device */ Status = XHwIcap_DeviceWrite(InstancePtr, &WriteBuffer[0], Index); if (Status != XST_SUCCESS) { return XST_FAILURE; } /* * Send DESYNC command */ Status = XHwIcap_CommandDesync(InstancePtr); if (Status != XST_SUCCESS) { return XST_FAILURE; } return XST_SUCCESS; }; u32 getWord (){ unsigned char byte; int digitIndex; u32 far_word; while(1){ byte = 0x00; digitIndex = 0; //get bytes from uart until RETURN is entered while(byte != 0x0d){ byte = inbyte(); uartBuffer[digitIndex] = byte; xil_printf(\"%x\", byte); digitIndex++; } xil_printf(\"\\r\\n\"); if(digitIndex==5) { far_word = uartBuffer[0]","categories":[],"tags":[{"name":"FPGA, ZYNQ, Vitis","slug":"FPGA-ZYNQ-Vitis","permalink":"http://cj_song.gitee.io/myblogs/tags/FPGA-ZYNQ-Vitis/"}]},{"title":"使用ZYNQ实现单LUT内容的动态修改（一）PL端OOC设计流程","slug":"blog3_LUT内容读取1","date":"2020-10-23T07:00:00.000Z","updated":"2020-10-23T08:43:12.673Z","comments":true,"path":"2020/10/23/blog3-lut-nei-rong-du-qu-1/","link":"","permalink":"http://cj_song.gitee.io/myblogs/2020/10/23/blog3-lut-nei-rong-du-qu-1/","excerpt":"本文主要用于记录作者本人实现ZYNQ动态修改LUT内容过程中主要参考的资料，实现的步骤，遇到的问题等。主要参考的文章链接如下：https://cloud.tencent.com/developer/article/1528881，其中该工作大部分的原理部分该篇博客都有介绍，本篇博客不再赘述。","text":"本文主要用于记录作者本人实现ZYNQ动态修改LUT内容过程中主要参考的资料，实现的步骤，遇到的问题等。主要参考的文章链接如下：https://cloud.tencent.com/developer/article/1528881，其中该工作大部分的原理部分该篇博客都有介绍，本篇博客不再赘述。 一，摘要主要介绍一下使用Vivado进行部分动态重构系统的开发流程，AXI_HWICAP IP基本的使用方法，以及通过ARM部分实现LUT内容动态修改的程序流程(此部分见下篇博客)。 二，系统框图系统结构主要如上图，其中LUT的读写操作由PS端的程序控制，通过PC端的串口助手可以观察读取的配置帧数据，设置要修改的LUT位置以及修改后的LUT中的新数据。 三，PL工程的创建，综合，布局布线。考虑到调试过程中可能要多次设置目标LUT的初始值来搞清楚bitstream中数据与LUT中数据的映射关系，为了提高该系统的编译调试效率，本文针对目标操作的LUT采取局部动态重构的设计方法。实际应用中不采用部分重构设计流程也可以对LUT进行动态读写。以下是本次设计使用Vivado进行部分重构系统开发的整体流程： 使用Vivado创建整个设计，将部分重构模块保留为空模块。综合工程生成静态设计的.dcp文件(如top_syn_static.dcp)。 综合部分重构模块的源文件，生成对应的.dcp文件(如：pr_lut_syn.dcp)。 打开第一步生成的top_syn_static.dcp，读入第二步生成的pr_lut_syn.dcp，设置重构属性，保存设计点。 为重构模块指定重构区域，读入约束文件。 优化，布局，布线，保存设计点。 生成bitstream文件，及ila调试相关文件。 将重构模块清除保留为黑盒，将其他部分在布局布线后的级别上保存其设计点。 打开上一步保存的设计点，读入新的重构模块，优化，布局布线，保存设计点，生成bitstream等。 使用pr_verify指令对生成的bitstream进行验证。第一步，创建设计。可直接在给出的工程目录下面执行脚本自动创建，综合，以及硬件的导出。在工程目录下执行以下代码(windows下需要在Vivado的命令行下操作)：source ./tcl/step1_create_project.tcl 具体工程文件结构如下图所示：其中原理图部分如下：这一步我们要用到的文件为.\\vivado\\lut_modify.runs\\synth_1\\top.dcp，我们需要将此文件复制到.\\checkpoints\\synth\\static\\路径下，便于后续操作。当然也可以自己手动来创建工程，编写相关文件。第二步，综合重构模块直接执行脚本文件即可，脚本代码如下：read_verilog ./src/rms/pr_lut1/pr_lut.v synth_design -mode out_of_context -flatten_hierarchy rebuilt -top pr_lut -part xc7z020clg400-1 write_checkpoint ./checkpoints/synth/rms/pr_lut1.dcp close_design close_project 以下是重构模块的verilog代码，该模块例化一个内部的固定位置的LUT，便于我们以后寻址更改其内部内容：timescale 1ns/1ps //******************* //DEFINE MODULE PORT //******************* module pr_lut ( input clk , input rst , input [5:0] din , output reg dout ) ; //********************* //INNER SIGNAL DECLARATION //********************* //REGS reg [5:0] din_ff ; //WIRES wire dout_pre ; //********************* //MAIN CORE //********************* always @(posedge clk or posedge rst) begin if (rst == 1'b1) begin din_ff { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"FPGA, ZYNQ, LUT","slug":"FPGA-ZYNQ-LUT","permalink":"http://cj_song.gitee.io/myblogs/tags/FPGA-ZYNQ-LUT/"}]},{"title":"Adam论文翻译","slug":"blog2_Adam论文翻译","date":"2020-08-13T10:15:00.000Z","updated":"2020-08-13T11:23:31.078Z","comments":true,"path":"2020/08/13/blog2-adam-lun-wen-fan-yi/","link":"","permalink":"http://cj_song.gitee.io/myblogs/2020/08/13/blog2-adam-lun-wen-fan-yi/","excerpt":"本文为Adam算法原论文的翻译。","text":"本文为Adam算法原论文的翻译。 第一部分：引言​ 基于随机梯度的优化问题在许多科学和工程领域具有重要的实际意义。这些领域中的许多问题都可以归结为某个标量参数化目标函数的优化问题，这些目标函数要求对其参数进行最大化或最小化。如果函数的参数是可微的，梯度下降法是一种比较有效的优化方法，因为计算一阶偏导数w.r.t.的所有参数都与计算函数的计算复杂度相同。通常，目标函数是随机的。在这种情况下，可以用多个随机子函数组成的梯度函数或多个梯度子函数组成。SGD被证明是一种高效、有效的优化方法，在许多机器学习成功案例中起着核心作用，例如深度学习的最新进展（Deng等人，2013；Krizhevsky等人，2012；Hinton&amp;Salakhutdinov，2006；Hinton et al.，2012a；Graves et al.，2013）。目标也可能有数据子采样以外的其他噪声源，如辍学（Hinton等人，2012b）正则化。对于所有这些噪声目标，需要有效的随机优化技术。本文主要研究具有高维参数空间的随机目标优化问题。在这些情况下，高阶优化方法不适合，本文的讨论将局限于一阶方法。 ​ 我们提出了Adam，一种只需要一阶梯度且内存需求很少的高效随机优化方法。该方法根据梯度的一阶矩和二阶矩的估计来计算不同参数的个体自适应学习率；Adam的名字来源于自适应矩估计。我们的方法结合了最近流行的两种方法的优点：AdaGrad（Duchi et al.，2011）和RMSProp（Tieleman&amp;Hinton，2012），这两种方法在在线和非平稳环境下工作良好；第5节阐明了这些方法和其他随机优化方法的重要联系。Adam的一些优点是参数更新的大小对梯度的重定标是不变的，它的步长是由步长超参数近似限定的，它不需要一个平稳的目标，它与稀疏梯度一起工作，并且它自然地执行一种步长退火的形式。 算法1： $g_t^2$代表元素平方$g_t \\bigodot g_t$，被测试机器学习问题的良好的默认设置参数为$\\alpha = 0.001, \\beta_1=0.9,\\beta_2=0.99$ 以及$\\epsilon=10^{-8}$。对向量所有的操作都是基于元素的。对于$\\beta_1^t 与\\beta_2^t$表示$\\beta_1 \\beta_2$的t次方。 $ \\bf{Require: } \\quad\\alpha:\\; Stepsize$ $\\bf{Require:} \\quad\\beta_1,\\beta_2\\in[0,1): \\; Exponential\\;decay\\; rates\\; for\\; the\\; moment\\; estimates$ $ \\bf{Require: } \\quad f(\\theta):\\; Stochastic\\; objective\\; function\\; with\\; parameters\\; \\theta $ $ \\bf{Require: } \\quad\\theta_0:\\; Initial\\; parameter\\; vector $ $\\qquad m_0 \\leftarrow 0 (Initialize\\; 1^{st} \\;moment \\; vector) $ $\\qquad v_0 \\leftarrow 0 (Initialize\\; 2^{nd} \\;moment \\; vector) $ $\\qquad t \\leftarrow 0 (Initialize\\; timestep) $ $\\qquad \\bf{while} \\;\\theta_t \\; not\\; converged \\; \\bf{do} $ $\\qquad \\qquad t \\leftarrow t+1 $ $\\qquad \\qquad g_t \\leftarrow \\nabla_{\\theta}f_t(\\theta_t-1) \\;(Get\\; gradients\\; w.r.t.\\; stochastic\\; objective\\; at\\; timestep\\; t) $ $\\qquad \\qquad m_t \\leftarrow \\beta_1 \\cdot m_{t-1} +(1-\\beta_1)\\cdot g_t \\;(Update\\; biased\\; first\\; moment\\; estimate) $ $\\qquad \\qquad v_t \\leftarrow \\beta_2 \\cdot v_{t-1} +(1-\\beta_2)\\cdot g_t^2 \\;(Update\\; biased\\; second\\; raw\\; moment\\; estimate) $ $\\qquad \\qquad \\hat{m_t} \\leftarrow m_t/(1-\\beta_1^t) \\;(Compute\\; bias-corrected\\; first\\; moment\\; estimate) $ $\\qquad \\qquad \\hat{v_t} \\leftarrow v_t/(.1-\\beta_2^t) \\;(Compute\\; bias-corrected\\; second\\; raw \\; moment\\; estimate) $ $\\qquad \\qquad \\theta_t \\leftarrow \\theta{t-1} - \\alpha\\cdot \\hat{m_t}/(\\sqrt{\\hat v_t} +\\epsilon ) \\;(Update \\; parameters)$ $\\qquad \\bf{end\\; while}$ $\\qquad \\bf{return} \\; \\theta_t \\;(Resulting \\; parameters) $ ​ 第二节介绍了算法及其更新规则的性质。第3节介绍了我们的初始化偏差校正技术，第4节对在线凸规划中的Adam收敛性进行了理论分析。从经验上讲，我们的方法在各种模型和数据集上始终优于其他方法，如第6节所示。总的来说，我们证明了Adam是一个多功能的算法，可以扩展到大规模的高维机器学习问题。 第二部分：算法​ 我们提出的算法Adam的伪代码见算法1。设$f(\\theta)$是一个有噪声的目标函数：一个可微$w.r.t.$参数$ \\theta$的随机标量函数。我们感兴趣的是最小化这个函数的期望值，$\\mathbb{E}[f(\\theta)]\\,w.r.t. $它的参数$\\theta$。用$f_1(\\theta), \\cdots, f_T(\\theta) $表示随机函数在随后的时间步骤$1，\\cdots，T$的实现。随机性可能来自于对数据点的随机子样本（小批量）的评估，也可能来自固有的函数噪声。用$g_t=\\bigtriangledown_{\\theta}f_t(\\theta)$表示梯度，即在时间步长t处计算的$f_t，w.r.t\\;\\theta$的偏导数向量。 ​ 该算法更新梯度$m_t$和平方梯度$v_t$的指数移动平均，其中超参数$β_1，β_2\\in[0，1）$控制这些移动平均的指数衰减率。移动平均值本身就是梯度的第一个矩（平均值）和第二个原始矩（无中心方差）的估计值。然而，这些移动平均值被初始化为（向量）0，导致矩估计值偏向于零，特别是在初始时间步长期间，尤其是当衰减率很小（即$\\beta_s$接近1）时。好消息是，这种初始化偏差可以很容易地抵消，从而得到偏差校正的估计值$\\hat m_t$和$\\hat v_t$。有关更多详细信息，请参阅第3节。 ​ 注意，算法1的效率可以通过改变计算顺序（例如，用下面的行替换循环中的最后三行）来提高算法1的效率: \\alpha_t=\\frac {\\alpha \\cdot \\sqrt{1-\\beta^t_2}}{(1-\\beta^t_1)} \\theta_t = \\theta_{t-1}-\\frac{\\alpha_t\\cdot m_t}{(\\sqrt{v_t}+\\hat \\epsilon )}2.1 Adam更新率​ Adam更新规则的一个重要属性是它对步长的谨慎选择。假设$\\epsilon =0$，时间步长t在参数空间中采取的有效步骤为$\\Delta_t=\\alpha\\cdot \\frac{\\hat m_t}{\\sqrt{\\hat v_t}}. $ 有效步长有两个上界：在$(1-\\beta_1)&gt;\\sqrt{1-\\beta_2}$的情况下$\\left|\\Delta_{t}\\right| \\leq \\alpha \\cdot\\left(1-\\beta_{1}\\right) / \\sqrt{1-\\beta_{2}} $,以及$\\left|\\Delta_{t}\\right| \\leq \\alpha$。否则,第一种情况只发生在最严重的稀疏情况下：梯度在除当前时间步以外的所有时间步上都为零。对于较少稀疏的情况，有效步长将更小。当$\\left(1-\\beta_{1}\\right)=\\sqrt{1-\\beta_{2}}$情况下，有$\\left|\\hat{m}_{t} / \\sqrt{\\hat{v}_{t}}\\right|&lt;1$因此$\\left|\\Delta_{t}\\right|&lt;\\alpha$。在更普通的场景中，因为$|\\mathbb{E}[g] / \\sqrt{\\mathbb{E}\\left[g^{2}\\right]}| \\leq 1$我们有$\\widehat{m}_{t} / \\sqrt{\\widehat{v}_{t}} \\approx \\pm 1$ .每个时间步在参数空间中所采取的有效步长近似为步长设置α的范围，即$\\left|\\Delta_{t}\\right| \\leqq \\alpha$。这可以理解为在当前参数值周围建立一个信任区域，超过该区域，当前梯度估计无法提供足够的信息。这通常使得提前知道α的正确刻度相对容易。例如，对于许多机器学习模型，我们通常预先知道好的最优解在参数空间的某个集合区域内具有高概率；例如，对参数具有先验分布的情况并不少见。由于α在参数空间中设置了步长（的上界），我们通常可以推导出α的正确量级，从而在一定的迭代次数内从$\\theta_0$到达最优值。稍加滥用术语，我们将比率$\\hat{m}_{t} / \\sqrt{\\widehat{v}_{t}}$称为信噪比$（SNR）$。信噪比越小，有效步长$∆t$将更接近于零。这是一个理想的特性，因为较小的信噪比意味着$\\hat m_t$的方向是否与真实梯度的方向相对应存在更大的不确定性。例如，$SNR$值通常会向最优值靠拢，从而导致参数空间中的有效步长更小：这是自动退火的一种形式。有效步长$∆t$也与梯度的比例不变性；用系数c重新缩放梯度g将用系数c缩放$\\hat{m}_{t}$，用系数$c^2$缩放$\\hat{v}_{t}$这抵消了$\\hat{m}_{t} / \\sqrt{\\widehat{v}_{t}}\\left(c \\cdot \\hat{m}_{t}\\right) /(\\sqrt{c^{2} \\cdot \\hat{v}_{t}})=\\hat{m}_{t} / \\sqrt{\\hat{v}_{t}}$。 第三部分：初始化偏差校正​ 如第2节所述，Adam使用初始化偏差校正项。我们将在这里导出二阶矩估计的项；一阶矩估计的推导完全类似。设g是随机目标f的梯度，我们希望用平方梯度的指数移动平均估计其第二原始矩（无中心方差），衰减率为$β2$。设$g_1，\\cdots，g_T$为后续时间步的梯度，每个都是从基本梯度分布$g_t∼p(gT)$中提取的。让我们将指数移动平均值初始化为$v_0=0$（零向量）。首先注意指数移动平均值$v_{t}=\\beta_{2} \\cdot v_{t-1}+\\left(1-\\beta_{2}\\right) \\cdot g_{t}^{2}$（其中$g_t^2$表明了元素平方$g_t\\odot g_t$）在时间步长t处的更新可以写成所有先前时间步长的梯度函数： v_{t}=\\left(1-\\beta_{2}\\right) \\sum_{i=1}^{t} \\beta_{2}^{t-i} \\cdot g_{i}^{2} \\tag{1}​ 我们想知道时间步长t处指数移动平均值的期望值$\\mathbb{E}\\left[v_{t}\\right]$是如何与真实的第二时刻$\\mathbb{E}\\left[g_{t}^2\\right]$相关的，因此我们可以纠正两者之间的差异。取等式（1）左右两侧的期望值： \\begin{aligned} \\mathbb{E}\\left[v_{t}\\right] &=\\mathbb{E}\\left[\\left(1-\\beta_{2}\\right) \\sum_{i=1}^{t} \\beta_{2}^{t-i} \\cdot g_{i}^{2}\\right] \\\\ &=\\mathbb{E}\\left[g_{t}^{2}\\right] \\cdot\\left(1-\\beta_{2}\\right) \\sum_{i=1}^{t} \\beta_{2}^{t-i}+\\zeta \\\\ &=\\mathbb{E}\\left[g_{t}^{2}\\right] \\cdot\\left(1-\\beta_{2}^{t}\\right)+\\zeta \\end{aligned}​ 式中：$ζ=0$，如果真实第二力矩$\\mathbb{E}\\left[g_{i}^2\\right]$是静止的；否则，$ζ$可以保持较小，因为指数衰减率$β1$可以（并且应该）被选择为指数移动平均为过去太远的梯度分配小权重。剩下的是项$（1−β_t)$，这是由用零初始化运行平均值引起的。因此，在算法1中，我们用这个项来修正初始化偏差。 ​ 在稀疏梯度的情况下，为了可靠地估计二阶矩，需要通过选择较小的$β2$值对许多梯度进行平均；然而，正是在小$β2$的情况下，缺少初始化偏差校正将导致初始步骤大得多。 第四部分：收敛性分析​ 我们使用（Zinkevich，2003）提出的在线学习框架来分析Adam的收敛性。给定凸代价函数$f_1（θ），f_2（θ），\\cdots，f_T（θ）$的任意未知序列。在每个时刻$t$，我们的目标是预测参数$θ_t$，并在先前未知的代价函数$f_t$上对其进行评估。由于序列的性质是预先未知的，因此我们使用遗憾来评估我们的算法，即在线预测$f_t(θt)$与来自前面所有步骤的可行集$\\mathcal{X}$。具体地说，遗憾是指： R(T)=\\sum_{t=1}^{T}\\left[f_{t}\\left(\\theta_{t}\\right)-f_{t}\\left(\\theta^{*}\\right)\\right] \\tag{5}​ 其中$\\theta^{*}=\\arg \\min _{\\theta \\in \\mathcal{X}} \\sum_{t=1}^{T} f_{t}(\\theta)$。我们证明Adam没有遗憾边界，并在附录中给出了证明。我们的结果与一般凸在线学习问题的已知界相当。我们还使用一些定义来简化我们的符号，其中$g_{t} \\triangleq \\nabla f_{t}\\left(\\theta_{t}\\right)$和$g_{t,i}$作为第i个元素。我们将$g_{1: t, i} \\in \\mathbb{R}^{t}$定义为一个向量，它包含所有迭代过程中梯度的第i维，直到t，$g_{1: t, i}=\\left[g_{1, i}, g_{2, i}, \\cdots, g_{t, i}\\right]$。同样，我们定义$\\gamma \\triangleq \\frac{\\beta_{1}^{2}}{\\sqrt{\\beta_{2}}}$。当学习速率$α_t$以$t-1$的速率衰减时，我们的以下定理成立，并且第一时刻平均系数$β_{1,t}$以$λ$指数衰减，通常接近1，例如$1-10^{-8}$。 定理4.1. 假设函数ft具有有界梯度，$\\left|\\nabla f_{t}(\\theta)\\right|_{2} \\leq G,\\left|\\nabla f_{t}(\\theta)\\right|_{\\infty} \\leqq G_{\\infty}$对于所有的$\\theta \\in R^{d }$并且Adam生成的任何$θt$之间的距离是有界的，$\\left|\\theta_{n}-\\theta_{m}\\right|_{2} \\leq D, \\left|\\theta_{m}-\\theta_{n}\\right|_{\\infty} \\leq D_{\\infty}$对于任何$m, n \\in\\{1, \\ldots, T\\}, \\text { and } \\beta_{1}, \\beta_{2} \\in[0,1)$满足$\\frac{\\beta_{1}^{2}}{\\sqrt{\\beta_{2}}}&lt;1$，让$\\alpha_{t}=\\frac{\\alpha}{\\sqrt{t}}$并且$\\beta_{1, t}=\\beta_{1} \\lambda^{t-1}, \\lambda \\in(0,1)$。Adam对于所有$T≥1$达到以下保证。 R(T) \\leq \\frac{D^{2}}{2 \\alpha\\left(1-\\beta_{1}\\right)} \\sum_{i=1}^{d} \\sqrt{T \\hat{v}_{T, i}}+\\frac{\\alpha\\left(1+\\beta_{1}\\right) G_{\\infty}}{\\left(1-\\beta_{1}\\right) \\sqrt{1-\\beta_{2}}(1-\\gamma)^{2}} \\sum_{i=1}^{d}\\left\\|g_{1: T, i}\\right\\|_{2}+\\sum_{i=1}^{d} \\frac{D_{\\infty}^{2} G_{\\infty} \\sqrt{1-\\beta_{2}}}{2 \\alpha\\left(1-\\beta_{1}\\right)(1-\\lambda)^{2}} 我们的定理4.1表明，当数据特征是稀疏且有界梯度时，求和项可以远小于其上限$\\sum_{i=1}^{d}\\left|g_{1: T, i}\\right|_{2}&lt;&lt;d G_{\\infty} \\sqrt{T}$并且$\\sum_{i=1}^{d} \\sqrt{T \\widehat{v}_{T, i}}&lt;&lt;d G_{\\infty} \\sqrt{T}$,尤其是如果函数和数据特征的类别是第1.2节(Duchi等人，2011）的形式。他们对期望值$\\mathbb{E}\\left[\\sum_{i=1}^{d}\\left|g_{1: T, i}\\right|_{2}\\right]$的结果也适用于Adam。通常，类似于Adam与Adagrad的自适应方法，可以实现$O(\\log d \\sqrt{T})$相比于非自适应方法计算复杂度$O(\\sqrt{d T})$的改进。在我们的理论分析中，将$β_{1,t}$衰减为零是很重要的，也与以前的经验结果相吻合，例如（Sutskever等人，2013年）表明在训练结束时降低动量系数可以提高收敛性。最后，我们可以展示Adam的平均遗憾. 推论4.2.假设函数$f_t$具有有界梯度，$\\left|\\nabla f_{t}(\\theta)\\right|_{2} \\leq G,\\left|\\nabla f_{t}(\\theta)\\right|_{\\infty} \\leq G_{\\infty} \\text { for all } \\theta \\in R^{d}$并且Adam生成的任何$θt$之间的距离是有界的，$\\left|\\theta_{n}-\\theta_{m}\\right|_{2} \\leq D,\\left|\\theta_{m}-\\theta_{n}\\right|_{\\infty} \\leq D_{\\infty}$对任意的$m, n \\in\\{1, \\ldots, T\\}$。Adam达到以下保证，对于所有$T≥1$。 \\frac{R(T)}{T}=O\\left(\\frac{1}{\\sqrt{T}}\\right)利用定理4.1和$\\sum_{i=1}^{d}\\left|g_{1: T, i}\\right|_{2} \\leq d G_{\\infty} \\sqrt{T}$可以得到这个结果。因此，$\\lim _{T \\rightarrow \\infty} \\frac{R(T)}{T}=0$。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Adam, 优化算法","slug":"Adam-优化算法","permalink":"http://cj_song.gitee.io/myblogs/tags/Adam-%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"}]},{"title":"Windows下安装hexo并部署网站","slug":"blog1_安装hexo以及网站的部署","date":"2020-08-04T14:00:00.000Z","updated":"2020-08-05T02:27:01.164Z","comments":true,"path":"2020/08/04/blog1-an-zhuang-hexo-yi-ji-wang-zhan-de-bu-shu/","link":"","permalink":"http://cj_song.gitee.io/myblogs/2020/08/04/blog1-an-zhuang-hexo-yi-ji-wang-zhan-de-bu-shu/","excerpt":"本文主要介绍在Windows操作系统上使用hexo生成个人博客的软件安装及环境配置，同时记录了过程中用到的相关命令。","text":"本文主要介绍在Windows操作系统上使用hexo生成个人博客的软件安装及环境配置，同时记录了过程中用到的相关命令。 一、安装node.jswindows版本的官网链接为：https://nodejs.org/en/ ，安装过程中CustomSetup这一步记得检查Add—to-PATH是否被选上。 安装完成后命令行输入以下命令检查环境是否配好，正常情况下会返回软件版本号。 npm -v 二、安装hexo在Windows的cmd命令行中输入以下命令安装hexo并验证。 npm install -g hexo hexo -v 如果出现以下错误： hexo : 无法加载文件 C:\\Users\\45478\\AppData\\Roaming\\npm\\hexo.ps1，因为在此系统上禁止运行脚本。 可在管理员模式下的powershell中执行以下命令，输入y回车，之后问题解决。 set-ExecutionPolicy RemoteSigned 三、生成博客步骤为创建工作目录，工作目录初始化，生成博客，开启本地服务预览网站。指令代码如下。 hexo init hexo generate hexo server 四、部署网站 首先执行以下命令安装hexo-deployer-git。 npm install hexo-deployer-git --save 网站的部署可以参考hexo的官方教程，主要用到的命令如下。 hexo deploy deploy之前需要更改_config.yml中deploy段的参数，可使用多个deployer。 deploy: - type: git repo: - type: heroku repo: 修改配置。 deploy: type: git repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: [branch] message: [message] 生成站点文件并推送至远程库。执行以下指令hexo clean hexo deploy 五、HEXO主题可以在官网的主题页面找适合自己的主题，本文所用的主题为volantis，在此对主题的作者表示崇高的敬意！！! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"hexo, 部署网站","slug":"hexo-部署网站","permalink":"http://cj_song.gitee.io/myblogs/tags/hexo-%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-07-22T07:25:31.423Z","updated":"2020-07-11T07:28:00.000Z","comments":true,"path":"2020/07/22/hello-world/","link":"","permalink":"http://cj_song.gitee.io/myblogs/2020/07/22/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"盾构，webots","slug":"盾构，webots","permalink":"http://cj_song.gitee.io/myblogs/tags/%E7%9B%BE%E6%9E%84%EF%BC%8Cwebots/"},{"name":"液压缸，matlab","slug":"液压缸，matlab","permalink":"http://cj_song.gitee.io/myblogs/tags/%E6%B6%B2%E5%8E%8B%E7%BC%B8%EF%BC%8Cmatlab/"},{"name":"机器人，matlab","slug":"机器人，matlab","permalink":"http://cj_song.gitee.io/myblogs/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA%EF%BC%8Cmatlab/"},{"name":"ROS2, Bash。","slug":"ROS2-Bash。","permalink":"http://cj_song.gitee.io/myblogs/tags/ROS2-Bash%E3%80%82/"},{"name":"FPGA, ZYNQ, Vitis","slug":"FPGA-ZYNQ-Vitis","permalink":"http://cj_song.gitee.io/myblogs/tags/FPGA-ZYNQ-Vitis/"},{"name":"FPGA, ZYNQ, LUT","slug":"FPGA-ZYNQ-LUT","permalink":"http://cj_song.gitee.io/myblogs/tags/FPGA-ZYNQ-LUT/"},{"name":"Adam, 优化算法","slug":"Adam-优化算法","permalink":"http://cj_song.gitee.io/myblogs/tags/Adam-%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"},{"name":"hexo, 部署网站","slug":"hexo-部署网站","permalink":"http://cj_song.gitee.io/myblogs/tags/hexo-%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99/"}]}